[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to spatial statistics: Spatial Analysis with R - 111019",
    "section": "",
    "text": "R is an object-oriented programming language and environment for statistical computing that provides relatively simple access to a wide variety of statistical techniques (R Core Team 2016). R offers a complete programming language with which to add new methods by defining functions or automating iterative processes.\nMany statistical techniques, from the classic to the latest methodologies, are available in R, with the user in charge of locating the package that best suits their needs.\nR can be considered as an integrated set of programs for data manipulation, calculation and graphics. Among other features R allows:\n\neffective data storage and manipulation,\noperators for calculation on indexed variables,\na comprehensive, coherent and integrated collection of data analysis tools,\nplotting possibilities, which work directly on screen or printer, and\na well-developed, simple and effective programming language, including conditionals, loops, recursive functions and the possibility of inputs and outputs.\n\nR is distributed as open source software, so obtaining it is completely free.\nR is also multiplatform software which means it can be installed and used in various operating systems (OS), mainly Windows and Linux. However, the available functions and packages syntax is practically the same in any OS. From an operational point of view, R consists of a base system and additional packages that extend its functionality. Among the main types of packages we found:\n\nThose that are part of the base system.\nThose that are not part of the base system, but are recommended (survival, nlme). In GNU/Linux and Windows these packages are already part of the standard distribution.\nOther packages such as UsingR, foreing, or Maptools. These must be selected and installed individually. We will see how to do this later.\n\nThe functions included in the packages installed by default, that is, those that are predefined in the basic installation R, are available for use at any time. However, in order to use the functions of new packages, specific calls must be made to those packages.\n\n\nThe installation of R depends on the operating system to be used. You can find all the necessary information in:\n\nhttp://cran.r-project.org/\nWindows: http://cran.r-project.org/bin/windows/\nLinux: http://cran.r-project.org/bin/linux/\n\nFor the development of this course we will use the Windows version but feel free to use whatever version fits your needs. The last version of R is downloadable from here. We will install the latest version available. Remember that you have to install the version that corresponds to the architecture of your OS (32 or 64 bits). In case of doubt install both versions or at least the 32-bit version, which will always work on our computer.\nInstallation in Windows is very simple. Just run the executable (.exe) file and follow the installation steps (basically say Yes to everything). Once R is installed, we will install RStudio an integrated development environment (IDE) that is more user-friendly than the basic R interface. RStudio provides a more complete environment and some useful tools such as:\n\nAutocomplete instructions1.\nObject management.\nData display and visualization.\nExporting plots and figures.\n\nWe will install the latest version of RStudio. You can see the installation steps in the installation video tutorial.\n\nNote that RStudio is just an interface. Any code block or instruction will work in any other R environment.\nBefore installing RStudio you need to have already installed the standard R software.\n\n\n\n\nBeing an open source software and with a strong collaborative component R has a large amount of resources and documentation relative to the specific syntax of the language itself (control structures, function creation, calls to objects …) and to every single package available as well.\nOn the other hand, R counts on a series of manuals which are available right after installing the software. You can find them in the installation directory of R (C:Files-X.X.X). These manuals and many others can also be downloaded from the R project website:\n\nWriting R extensions.\nR data import / export.\nThe R language definition.\nR installation and administration.\nAn introduction to R.\n\nFinally, in addition to the wide repertoire of manuals available, there is also a wide range of resources and online help including:\n\nhttp://www.r-bloggers.com/. A website dedicated to R development of tutorials.\nhttp://www.r-project.org/mail.html. R help mailing lists with various interest groups including the R (r-sig-geo) GIS user community.\nhttp://stackoverflow.com/. Website devoted to questions-and-answers on programming languages among which is R also available2.\nhttp://www.r-tutor.com/. A website devoted to teach statistics. An useful one if yo3u are not much familiar with basic statistical methods.\n\nIt is relatively important to become familiar from the beginning with the various alternatives for getting help. A key part of your success in using R lies in your ability to be self-relient and be able to get help and apply it to your own problems.\n\n\n\n\n\n\nR is basically a command line environment that allows the user to interact with the system to enter data, perform mathematical calculations or visualize results through plots and maps.\nFigure 1.1 shows standard appearance of the R console, which can be considered as a windows cmd like terminal or console. We have also seen what the terminal and working environment looks like in RStudio at the end of the installation process (Figure 1.2). A third possibility is to work directly on the cmd terminal (Figure 1.3). The commands and instructions are the same regardless of the environment that we chose. In this course we will focus on the use of RStudio, since it is the simplest of them all.\n\n\n\nR standard terminal\n\n\n\n\n\nRStudio interface\n\n\n\n\n\nR code terminal\n\n\nThe terminal (regardless of the chosen option) is usually the main working window and is where we will introduce the necessary instructions to carry out our operations. It is in this window where we will visualize the results from most instructions and objects we generate. An exception to this are plots and maps which are displayed in a specifically-devoted window located in the bottom-right corner.\n\n\n\n\nLet’s get started and insert our first command in the R’s terminal. When R is ready or awaiting us to input an instruction the terminal shows a cursor right after a &gt; symbol to indicate it.\n\n\n\n\n\nR waiting for sintructions\n\n\n\n\nAt this point it is necessary to take into account that R is an interpreted language, which means that the different instructions or functions that we specify are read and executed one by one. The procedure is more or less as follows. We introduce an instruction in the R console, the application interprets and executes it, and finally generates or returns the result.\nTo better understand this concept we will do a little test using the R console as a calculator. Open the working environment of RStudio if you did not already open it and enter the following statement and press enter:\n\n10+2\n\n[1] 12\n\n\nWhat just happened is that the R interpreter has read the instruction, in this case a simple arithmetic operation, executed it and returned the result. This is the basic way to proceed to enter operations. However, it will not be necessary for us to always enter the instructions manually. Later we will see how to create scripts or introduce blocks of instructions.\n\n\n\nWe have previously mentioned some features of R such as that R is an object-oriented language. But, what does this mean? It basically means that to perform any type of task we use objects. Everything in R is an object (functions, variables, results …). Thus, entities that are created and manipulated in R are called objects, including data, functions and other structures.\nObjects are stored and characterized by their name and content. Depending on the type of object we create that object will have a given set of characteristics. Generally the first objects one creates are those of variable type, in which we will be able to store a piece of data and information. The main objects of variable type in R are:\n\nNumber: an integer or decimal number depending on whether we specify decimal figures.\nFactor:a categorical variable or text.\nVector: a list of values of the same type.\nArray: a vector of k dimensions.\nMatrix: a particular case of array where k=2 (rows, cols).\nData.frame: table composed of vectors.\nList: vector with values of different types.\n\nObviously there are other types of objects in R. For example, another object with which we are going to familiarize ourselves is the model objects. We can create them by storing the output of executing some kind of model like a linear regression model for instance. Spatial data also fits in its particular variety of objects. Through the course we will see both models and spatial information (vector and raster).\n\n\nObjects in R are created by declaring a variable by specifying its name and then assign it a value using the &lt;- operator. We can also use = but the &lt;- operator is most commonly found in examples and manuals.\nSo, to create an object and assign it a value the basic instruction is composed of object name &lt;- value.\n\nn &lt;- 4\n\nTry to introduce the following instructions to create different kind of objects:\n\nn &lt;- 15\nx &lt;- 1.0\nname &lt;- \"Marcos\"\n\nWe can also store in an object the result form any operation:\n\nn &lt;- 10+2\n\nSo here is the thing. The type of object we create depends on the content that we assign. Therefor, if we assign a numeric value, we are creating an object of type number (integer or decimal) and if we assign a text string (any quoted text, either with single or double quotes), we are creating a text type object or string. Once created, the objects are visualized using calls using the name that we have assigned to the object. That is, we will write to the terminal in the name of the object and then its value will be shown.\n\nn\n\n[1] 12\n\nname\n\n[1] \"Marcos\"\n\n\nSome considerations to keep in mind when creating objects or working with R in general lines:\n\nR is case-sensitive so radio ≠ Radio\nIf a new value is assigned to an object it is overwritten and deletes the previous value.\nTextual information (also known as string or char) is entered between quotation marks, either single ('') or double (\"\").\nThe function ls() will show us in the terminal the objects created so far.\nIf the value obtained from an instruction is not assigned in an object it is only displayed in the terminal, it is not stored.\n\n\n\n\nOne of the most common objects in R is the vector. A vector can store several values, which must necessarily be of the same type (all numbers, all text, and so forth). There are several ways to create vectors. Try entering the following instructions and viewing the created objects.\n\nv1 &lt;- c(1,2,3,4,5)\nv1\n\n[1] 1 2 3 4 5\n\n\n\nv2 &lt;- 1:10\n\n\nv3 &lt;- -5:3\nv3\n\n[1] -5 -4 -3 -2 -1  0  1  2  3\n\n\n\nv4 &lt;- c('spatial','statistics','rules!!')\nv4\n\n[1] \"spatial\"    \"statistics\" \"rules!!\"   \n\n\nWe have just covered the basic methods for vector creation. The most common approach is use the function c() which allow as to introduce values manually by separatting them using ,.\n\nv1 &lt;- c(1, 2, 3, 4, 5)\nv1\n\n[1] 1 2 3 4 5\n\n\n\nv4 &lt;- c('spatial','statistics','rules!!')\nv4\n\n[1] \"spatial\"    \"statistics\" \"rules!!\"   \n\n\nAnother option that only works for vectors containing integer values is the use of : which produces a ordered sequence of numbers by adding 1 starting from the first value and finishing in the last.\n\nv2 &lt;- 1:10\n\n\nv3 &lt;- -5:3\nv3\n\n[1] -5 -4 -3 -2 -1  0  1  2  3\n\n\nVectors, lists, arrays, and data frames are indexed objects. This means that they store several values and assign to each of them a numerical index that indicates their position within the object. We can access the information stored in each of the positions by using name[position]:\n\nv1[1]\n\n[1] 1\n\n\nNote that opposite to most of the other programming languages, the index for the first position in an indexed object is 1, whereas Python, C++ and others use 0.\nAs with an unindexed object, it is possible to modify the information of a particular position using the combination name[position] and the assignment operator &lt;-. For example:\n\nv3[9] &lt;- 1000000\nv3[9]\n\n[1] 1e+06\n\n\nLet’s see some specific functions and basic operations for vectors and other indexed objects:\n\nlength(vector): Returns the number of positions of a vector.\nLogical operators &lt;,&gt;, ==,!=: Applying these operators on a vector returns a new vector with values TRUE/FALSE for each of the positions of the vector, depending on whether the given values satisfies or not the condition.\n\n\nlength(v3)\n\n[1] 9\n\n\n\nv4&lt;-1:5\nv4&gt;3\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\n\n\n\n\nOnce we have seen vectors we go to explore how objects of type list work. A list is an object similar to a vector with the difference that lists allow to store values of different type. Lists are created using the list(value1, value2, ...) function. For example:\n\nlist1 &lt;- list(1,7,\"Marcos\")\nlist1\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 7\n\n[[3]]\n[1] \"Marcos\"\n\n\nTo access the values stored in the different positions proceed in the same way we did with vectors, ie name[position]:\n\nlist1[3]\n\n[[1]]\n[1] \"Marcos\"\n\n\nWe can use the length() function with list too:\n\nlength(list1)\n\n[1] 3\n\n\n\n\n\nArrays are an extension of vectors, which add additional dimensions to store information. The most common case is the 2-dimensional matrix (rows and columns). To create an array, we use array(values, dimensions). Both values and dimensions are specified using vectors. In the following example we see how to create a matrix with 4 rows and 5 columns, thus containing 20 values, in this case correlative numbers from 1 to 20:\n\nmyarray&lt;- array(1:20,dim=c(4,5))\nmyarray\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    5    9   13   17\n[2,]    2    6   10   14   18\n[3,]    3    7   11   15   19\n[4,]    4    8   12   16   20\n\n\nTo access the stored values we will use a combination of row-and-column positions like matrix[row, col], where row indicates the row postition and col the column one. If we only assign value to one of the coordinates ([row,] or [,col]) we get the vector corresponding to the specified row or column.\n\nmyarray[3,2]\n\n[1] 7\n\nmyarray[3,]\n\n[1]  3  7 11 15 19\n\nmyarray[,2]\n\n[1] 5 6 7 8\n\n\n\n\n\nA data frame is used for storing data tables. It is a list of vectors of equal length. For example, the following variable df is a data frame containing three vectors n, s, b.\n\nn &lt;- c(2, 3, 5) \ns &lt;- c(\"aa\", \"bb\", \"cc\") \nb &lt;- c(TRUE, FALSE, TRUE) \ndf &lt;- data.frame(n, s, b)\n\nAs you can see, the function data.frame() is used to create the data.frame. However, we will seldom use these function to create objects or store data. Normally, we will call an instruction to read text files containing data or call data objects available in some packages.\n\n\n\n\nWe have seen so far aspects related to the creation of objects. However we should be also know how many objects we have created in our session and how to remove them if necessary. To display all created objects we use ls(). Deleting objects in R is done by the command remove rm(object) and then call to the garbage collector with gc() to free-up the occupied memory.\n\nls()\n\n [1] \"b\"       \"df\"      \"list1\"   \"myarray\" \"n\"       \"name\"    \"s\"      \n [8] \"v1\"      \"v2\"      \"v3\"      \"v4\"      \"x\"      \n\n\nIf we want to removal all the objects we have currently in our working session we can pass a list object containing the names of all objects to the gc() function. If you are thinking on combining gc()and ls()you are right. This would be the way:\n\nrm(list=ls())\ngc()\n\n          used (Mb) gc trigger (Mb) max used (Mb)\nNcells  589894 31.6    1256615 67.2  1256615 67.2\nVcells 1106851  8.5    8388608 64.0  1794589 13.7\n\n\n\n\n\nUp to this point we have seen and executed some instructions in R, generally oriented to the creation of objects or realization of simple arithmetic operations.\nHowever, we have also executed some function-type statements, such as the length() function. A function can be defined as a group of instructions that takes an input, uses this input to compute other values and returns a result or product. We will not go into very deep details, at least for now. It suffices to know that to execute a function it is enough to invoke the instruction that calls the desired function (length) and to specify the necessary inputs, also known as arguments. These inputs are always included between the parentheses of the instruction (length(vector)). If several arguments are needed we separate them using ,.\nSometimes we can refer to a given argument by using the argument’s name as is the case of the example we saw to delete all the objects in a session rm(list=ls()).\n\n\n\nSo far we have inserted instructions in the console but this is not the most efficient way to work. We will focus on the use of scripts which are an ordered set of instructions. This means we can write a text file with the instructions we want to insert and then run them at once.\nRStudio has an script development environment which opens in the top-left window. We can access the scripting window pressing File/New File/R script.\nFor additional information visit the RStudio support site.\n\n\n\nSo far we have seen how to enter data and create objects manually, but it is also possible, and in fact is most common, to read data from files and store it in an object. If the target data file is properly structured, we will create a matrix or a ‘data.frame’ object which we can manipulated afterwards.\n\n\nUsing data files normally requires us to specify the location of that file using paths. To avoid this, R has a tool that allow us to specify a target folder -the so-called working directory or folder- to work with.\nThe working directory is the default path for reading and writing files of any kind. We can know the path to the current working directory using the getwd() command. To set a new working directory, we use the command setwd(\"path\"). Remember that setwd() requires a string argument (whereas getwd() does not) to specify the path to the working directory (“path”).\n\ngetwd()\nsetwd('C:/Users/Marcos/Desktop/')\ngetwd()\n\nBy default, in Windows the working directory is set to the Documents folder.\nOnce the working directory is specified, everything we do in R (read files, export tables and/or graphics …) will be done in that directory. However, it is possible to work with other file system locations, specifying a different path through the arguments of some functions.\n\n\n\nR allows you to read any type of file in ASCII format (text files). The most frequently used functions are:\n\nread.table() and its different variations\nscan()\nread.fwf()\n\nFor the development of this course we will focus on using the read.table() function as it is quite versatile and easy to use. Before starting to use a new function we should always take a look at the available documentation. we will take this opportunity to show you how to do this in R so that you begin to become familiar R help.\nAny available function in R, regardless of being a standard one or belonging to an imported package has a documentation entry in the R help. R help describes us in detail the use of any function, providing information of the different arguments of the function, argument types, defaults, reference to the method (when applies) and even short code examples. To access the help we will use the help() function as follows:\n\nhelp(read.table)\n\nEntering the help() function we access the manual. In this case we can see a brief description of the function read.table() and its different variants (read.csv(), …). Below is the description of the arguments of the function, followed by some examples of application. This is the usual procedure for all functions available in R.\n\n\n\nHelp example\n\n\nIn case we use the regular R interface or the cmd terminal, the help entry will open in our default web browser.\nAt first glance the read.table() function seems to require many arguments, while its variations seem simpler. As already mentioned, arguments are just parameters that we can specify or change to execute a function, thus tunning the operation of the functions and the result to be obtained.\nArguments are specified within the function separated by commas (“,”). However, it is not necessary to assign a value to each one of them, since in the case of omitting an argument it is assigned a default value (always reported in the help entry). In the case of read.table() versus other functions like read.csv() the main advantage of using the first is that we can manipulate any argument, whereas most of them are fixed in the later. read.csv() is desigend to open comma separate files following the north-american standard (, as field delimiter and . as decimal separator). On the other hand, read.table() can potentially open any text file regardless of the separator, encoding, decimal format and so on so forth. Most of the executions of read.table() consist of:\n\n💡read.table(file,header=TRUE, sep=“,”,dec=“.”)\n\n\nfile: path and name of the file to open.\nheader: TRUE/FALSE argument to determine whether the first row of the data file contains column names.\nsep: field or column separator4.\ndec: decimal separator.\n\nLet’s see an example of reading file. We will read the file coordinates.txt, located in the Data directory. The file is structured in 3 columns with heading and separated by “;”. Al data are integer so no decimal separator is needed. See Table 2.2.\n\n\n\nStructure of the coordinates.txt file.\n\n\nFID_1\nX_INDEX\nY_INDEX\n\n\n\n\n364011\n82500\n4653500\n\n\n371655\n110500\n4661500\n\n\n487720\n55500\n4805500\n\n\n474504\n28500\n4783500\n\n\n436415\n85500\n4729500\n\n\n457549\n38500\n4757500\n\n\n469377\n39500\n4775500\n\n\n397162\n124500\n4687500\n\n\n434666\n41500\n4727500\n\n\n478383\n49500\n4789500\n\n\n488973\n329500\n4807500\n\n\n394153\n77500\n4684500\n\n\n426962\n36500\n4718500\n\n\n362216\n148500\n4651500\n\n\n\n\n\nThe process to follow is:\n\nSet working directory.\nUse the function to save the data in an object.\n\nIf we do…\n\nsetwd('.C/Users/Pere/INTRO_R/')\nread.table('./data/Module_1/coordinates.txt',header=TRUE,sep=';')\n\n…as we have not specified any object in which to store the result of the function, the contents of the file are simply printed on the terminal. This is a usual mistake, don’t worry. To store and later access the contents of the file we will do the following:\n\ntable&lt;-read.table('./data/Module_1/coordinates.txt',header=TRUE,sep=';')\ntable\n\n    FID_1 X_INDEX Y_INDEX\n1  364011   82500 4653500\n2  371655  110500 4661500\n3  487720   55500 4805500\n4  474504   28500 4783500\n5  436415   85500 4729500\n6  457549   38500 4757500\n7  469377   39500 4775500\n8  397162  124500 4687500\n9  434666   41500 4727500\n10 478383   49500 4789500\n11 488973  329500 4807500\n12 394153   77500 4684500\n13 426962   36500 4718500\n14 362216  148500 4651500\n\n\nPlease note that:\n\nYou have to specify your own working directory.\nThe path to the directory is specified in text format, so you type “in quotation marks”.\nThe name of the file to be read is also specified as text.\nThe header argument only accepts TRUE or FALSE values.\nThe sep argument also requires text values to enter the separator5.\nIt is advisable to save the data an object (table &lt;-).\n\nThe result of read.table() is an array stored in an object named table. Since read.table() returns an array we can manipulate our table using the same procedure described in the @ref(arrays) section.\n\ntable[,1]\n\n [1] 364011 371655 487720 474504 436415 457549 469377 397162 434666 478383\n[11] 488973 394153 426962 362216\n\ntable[1,1]\n\n[1] 364011\n\n\nBelow we found some interesting functions to preview and verify the information, and to know the structure of the data we have just imported. These functions are normally used to take a quick look into the first and last rows of an array or data.frame object and also to describe the structure of a given object.\n\nhead(): displays the first rows of the array.\ntail(): displays the last rows of the array.\nstr(): displays the structure and data type (factor or number).\n\n\nhead(table)\n\n   FID_1 X_INDEX Y_INDEX\n1 364011   82500 4653500\n2 371655  110500 4661500\n3 487720   55500 4805500\n4 474504   28500 4783500\n5 436415   85500 4729500\n6 457549   38500 4757500\n\ntail(table)\n\n    FID_1 X_INDEX Y_INDEX\n9  434666   41500 4727500\n10 478383   49500 4789500\n11 488973  329500 4807500\n12 394153   77500 4684500\n13 426962   36500 4718500\n14 362216  148500 4651500\n\nstr(table)\n\n'data.frame':   14 obs. of  3 variables:\n $ FID_1  : int  364011 371655 487720 474504 436415 457549 469377 397162 434666 478383 ...\n $ X_INDEX: int  82500 110500 55500 28500 85500 38500 39500 124500 41500 49500 ...\n $ Y_INDEX: int  4653500 4661500 4805500 4783500 4729500 4757500 4775500 4687500 4727500 4789500 ...\n\n\nAs already mentioned, read.table() is adequate to start reading of files to incorporate data into our working session in R. In any case we must be aware that there are other possibilities such as the read.csv() and read.csv2() that we have already seen when accessing the read.table() description. These functions are variations that defaults some arguments such as the field separator (columns) or the decimal character. In the help of the function you have information about it.\n\n\n\nOf course, we can also write text files from our data. The procedure is quite similar to read data but using write.table() instead of read.table. Remember that the created files are saved into the working directory, unless you specify an alternative path in the function arguments. As always, before starting the first thing is to consult the help of the function.\n\nhelp(\"write.table\")\n\nThe arguments of the function are similar to those already seen in read.table ():\n\n💡write.table(object,file,names,sep)\n\n\nobject: object of type matrix (or dataframe) to write.\nfile: name and path to the created file (in text format).\nrow.names: add or not (TRUE or FALSE) queue names. FALSE is recommended.\nsep: column separator (in text format).\ndec: decimal separator (in text format).\n\nTry the following instructions6 and observe the different results:\n\nwrite.table(table,'table1.txt',row.names=TRUE,sep='\\t')\nwrite.table(table,'table2.txt',row.names=FALSE,sep='\\t')\nwrite.table(table,'table3.txt',row.names=FALSE,sep=';')\nwrite.table(table,'your path/table4.txt',sep=';')\nwrite.csv(table,'your path/table5.csv')\n\n\n\n\nLet’s see the most common instructions for manipulating and extracting information in R. Specifically we will see how to extract subsets of data from objects of type vector, array or dataframe. We will also see how to create new data sets from the aggregation of several objects. There are many commands that allow us to manipulate our data in R. Many things can be understood as manipulation but for the moment we will focus on:\n\nSelect or extract information\nSort tables\nAdd rows or columns to a table\n\nAs you might already guess, we will work with tabular data like arrays and data.frames which we further refer to as tables.\n\n\nThe first thing we will do is access the information stored in the column(s) of a given table object. There are two basic ways to do this:\n\nUsing the position index of the column.\nUsing the name (header) of the column.\n\nThese two basic forms are not always interchangeable, so we will use one or the other depending on the case. It is recommended that you use the one that feels most comfortable for you. However, in most examples the column position index is used since it is a numerical value that is very easily integrated with loops and other iterative processes.\n\n\nTo extract columns using the position index we will use a series of instructions similar to those already seen in extracting information from Arrays, Vectors and Lists. The following statement returns the information of the second column of the array object table and stores it in a new object that we called col2:\n\ncol2 &lt;- table[,2]\ncol2\n\n [1]  82500 110500  55500  28500  85500  38500  39500 124500  41500  49500\n[11] 329500  77500  36500 148500\n\n\nIt is also possible to extract a range of columns, proceeding in a similar way to what has already been seen in the creation of vectors. The following statement extracts columns 2 and 3 from the table object and stores them in a new object called cols:\n\ncols &lt;- table[,2:3]\ncols\n\n   X_INDEX Y_INDEX\n1    82500 4653500\n2   110500 4661500\n3    55500 4805500\n4    28500 4783500\n5    85500 4729500\n6    38500 4757500\n7    39500 4775500\n8   124500 4687500\n9    41500 4727500\n10   49500 4789500\n11  329500 4807500\n12   77500 4684500\n13   36500 4718500\n14  148500 4651500\n\n\nNow let’s see how to select columns using their name. Name extraction is performed using a combination of object and column name object using $ to separte object from column name. The following statement selects the column named Y_INDEX from the array object table and stores it in col.Y_INDEX:\n\ncol.Y_INDEX &lt;- table$Y_INDEX\ncol.Y_INDEX\n\n [1] 4653500 4661500 4805500 4783500 4729500 4757500 4775500 4687500 4727500\n[10] 4789500 4807500 4684500 4718500 4651500\n\n\nA key piece of information here is the name of the column which we need to know in advance. Well, we can check the original text file or inspect the object table using str(). We can also take look to the top-right window activaing the Environment sub-window and unwrap table but be aware this can be only accessed using RStudio.\nThe main difference between these two methods is that index selection makes it possible to extract column ranges easily. To do this using the name of the columns you have to use functions like subset():\n\ncols2 &lt;- subset(table, select = c(X_INDEX,Y_INDEX))\n\nUsing the argument select we can point the columns that we want to extract using a vector with column names. Using subset() it is also possible to specify the columns that we do NOT want to extract. To do this proceed as follows:\n\ncols2 &lt;- subset(table, select = -c(X_INDEX,Y_INDEX))\n\nIn this way we would only extract the first column, excluding X_INDEX and Y_INDEX. Of cours, we can do this using the column index as well:\n\ncols2 &lt;- table[,-(2:3)]\n\n\n\n\nThe main reason why we are learning how to manipulate table columns is to be able to prepare our data for other purposes. It may be the case we need to join tables or columns that proceed from the same original table. The instruction cbind() allow us to merge together several tables and/or vectors provided they have the same number of rows. We can merge as many objects as we want to, by separating them using ,:\n\ncols3 &lt;- cbind(col2,cols2)\ncols3\n\n        col2  cols2\n [1,]  82500 364011\n [2,] 110500 371655\n [3,]  55500 487720\n [4,]  28500 474504\n [5,]  85500 436415\n [6,]  38500 457549\n [7,]  39500 469377\n [8,] 124500 397162\n [9,]  41500 434666\n[10,]  49500 478383\n[11,] 329500 488973\n[12,]  77500 394153\n[13,]  36500 426962\n[14,] 148500 362216\n\n\n\n\n\nIt is often the case we need to alter or change the name of a table object. If we wanted to rename all the columns of an object we would to pass a vector with names to the function colnames() in case we are renaming an array or names() if we are dealing with a data.frame. Note that the vector should have the same length as the total number of columns. Lets rename our table cols3:\n\ncolnames(cols3)&lt;- c(\"COL1\",\"COL2\")\n\nWhat if we want to change only a given name. Then we just point to the column header using the position index like this:\n\ncolnames(cols3)[2]&lt;- \"RENAMED COLUMN\"\n\nYou may be wondering How can we know what kind of object is my table?. That is a very good question. Specially at the begining is quite difficult to be in control this stuff. If you use RStudio you already see a description of the objects in the top-right window. array or matrix objects show something like [1:14,1:2] indicating multiple dimensions, vectors are similar but with only 1 dimension [1:14] and data.frames show the word data.frame in their description. However, this is not the fancy way to deal with object types. Just for the record, when we mean type an actual code developer means class. Of course there is a function called class() that returns the class an object belongs to:\n\nclass(cols3)\n\n[1] \"matrix\" \"array\" \n\n\n\n\n\nFinally, let’s look at how to sort columns and arrays. To sort a column in R, the sort() function is used. The general function of the function is:\n\nsort(cols3[,1])\n\n [1]  28500  36500  38500  39500  41500  49500  55500  77500  82500  85500\n[11] 110500 124500 148500 329500\n\n\nIf we want to reorder an array based on the values of one of its columns, we will use the order () function. The general operation of the function is:\n\ntable[order(table$X_INDEX),]\n\n    FID_1 X_INDEX Y_INDEX\n4  474504   28500 4783500\n13 426962   36500 4718500\n6  457549   38500 4757500\n7  469377   39500 4775500\n9  434666   41500 4727500\n10 478383   49500 4789500\n3  487720   55500 4805500\n12 394153   77500 4684500\n1  364011   82500 4653500\n5  436415   85500 4729500\n2  371655  110500 4661500\n8  397162  124500 4687500\n14 362216  148500 4651500\n11 488973  329500 4807500\n\n\nTo be honest, in this last example we are actually working with rows. Take a look at the position of the ,. The brackets are also something that we will use later to extract data from a table. But it feels right to bring here the order() command right after sort().\n\n\n\n\nLet us now turn to the manipulation of rows. The procedure is basically the same as in the case of columns, except for the fact that we normally do not work with names assigned to rows (although that’s a possibility), but we refer to a row using its position. To extract rows or combine several objects according to their rows we use the following expressions:\n\nrow1 &lt;- table[1:5,]\nrow2 &lt;- table[-(6:7),]\nrow3 &lt;- rbind(row1,row2)\n\nSame as with Arrays we point to rows instead of columns when we use the index value to the left of the [row,col]. So that’s the thing, we just change that and we are dealing with rows. We can join rows and tables using the rbind() function rather than cbind(). r stands for row and c for column.\nWe can extract a subsample of rows that meet a given criteria:\n\n💡table[criteria,]\n\n\ntable[table$X_INDEX==82500,]\n\n   FID_1 X_INDEX Y_INDEX\n1 364011   82500 4653500\n\ntable[table$X_INDEX&gt;82500,]\n\n    FID_1 X_INDEX Y_INDEX\n2  371655  110500 4661500\n5  436415   85500 4729500\n8  397162  124500 4687500\n11 488973  329500 4807500\n14 362216  148500 4651500\n\n\nOh, we expect you to have found out this by yourself but evidently we can combine row and column manipulation if that fits our purpose.\n\n\n\n\n\n\n\nThere are a large number of functions in the basic installation of R. It would be practically impossible to see all of them so we will see some of the most used, although we must remember that not only is there the possibility of using predesigned functions, but R also offers the possibility to create your own functions.\nBelow are some of the basic statistical functions that we can find in R. These functions are generally applied matrix-array or data.frame data objects. Some of them can be applied to the whole table and others to single columns or rows.\n\nsum() Add values.\nmax() Returns the maximum value.\nmin() Returns the minimum value.\nmean() Calculates the mean.\nmedian() Returns the median.\nsd() Calculates the standard deviation.\nsummary() Returns a statistical summary of the columns.\n\nWe are going to apply them using some example data. We will use the data stored in the file fires.csv, inside the Data folder (Table 3.1). This file contains data on the annual number of fires between 1985 and 2009 in several European countries.\n\nfires &lt;- read.csv2(\"./data/Module_1/fires.csv\",header=TRUE)\nknitr::kable(coords,caption = \"Structure of the fires.csv file.\")\n\n\nStructure of the fires.csv file.\n\n\nFID_1\nX_INDEX\nY_INDEX\n\n\n\n\n364011\n82500\n4653500\n\n\n371655\n110500\n4661500\n\n\n487720\n55500\n4805500\n\n\n474504\n28500\n4783500\n\n\n436415\n85500\n4729500\n\n\n457549\n38500\n4757500\n\n\n469377\n39500\n4775500\n\n\n397162\n124500\n4687500\n\n\n434666\n41500\n4727500\n\n\n478383\n49500\n4789500\n\n\n488973\n329500\n4807500\n\n\n394153\n77500\n4684500\n\n\n426962\n36500\n4718500\n\n\n362216\n148500\n4651500\n\n\n\n\n\nThe first thing is to import the file into a table.\n\nfires &lt;- read.table(\"./data/Module_1/fires.csv\",header=TRUE,sep=',')\n\nOnce data is imported we can take a look at the structure to make sure that everything went well. We should have integer values for each region:\n\nstr(fires)\n\n'data.frame':   25 obs. of  7 variables:\n $ YEAR    : int  1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 ...\n $ PORTUGAL: int  8441 5036 7705 6131 21896 10745 14327 14954 16101 19983 ...\n $ SPAIN   : int  12238 7570 8679 9247 20811 12913 13531 15955 14254 19263 ...\n $ FRANCE  : int  6249 4353 3043 2837 6763 5881 3888 4002 4769 4618 ...\n $ ITALY   : int  18664 9398 11972 13588 9669 14477 11965 14641 14412 11588 ...\n $ GREECE  : int  1442 1082 1266 1898 1284 1322 858 2582 2406 1763 ...\n $ EUMED   : int  47034 27439 32665 33701 60423 45338 44569 52134 51942 57215 ...\n\n\nNow we will calculate some descriptive statistics for each column to have a first approximation to the distribution of our data. To do this we will use the function summary() that will return some basic statistical values such as:\n\nQuantile\nMean\nMedian\nMaximum\nMinimum\n\n\nsummary(fires)\n\n      YEAR         PORTUGAL         SPAIN           FRANCE         ITALY      \n Min.   :1985   Min.   : 5036   Min.   : 7570   Min.   :2781   Min.   : 4601  \n 1st Qu.:1991   1st Qu.:14327   1st Qu.:12913   1st Qu.:4002   1st Qu.: 7134  \n Median :1997   Median :21870   Median :16771   Median :4618   Median : 9540  \n Mean   :1997   Mean   :20848   Mean   :16937   Mean   :4907   Mean   : 9901  \n 3rd Qu.:2003   3rd Qu.:26488   3rd Qu.:20811   3rd Qu.:6249   3rd Qu.:11965  \n Max.   :2009   Max.   :35697   Max.   :25827   Max.   :8005   Max.   :18664  \n     GREECE         EUMED      \n Min.   : 858   Min.   :27439  \n 1st Qu.:1322   1st Qu.:45623  \n Median :1486   Median :55215  \n Mean   :1656   Mean   :54249  \n 3rd Qu.:1898   3rd Qu.:62399  \n Max.   :2582   Max.   :75382  \n\n\nThe summary() function is not only used to obtain summaries of data through descriptive statistics, but can also be used in model type objects to obtain a statistical summary of the results, coefficients, significance … Later we will see an example of this applied on a linear regression model.\nLet’s now see what happens if we apply some of the functions presented above. Try running the following instructions:\n\nsum(fires)\n\n[1] 2762377\n\nmax(fires)\n\n[1] 75382\n\nmin(fires)\n\n[1] 858\n\n\nAs can be seen these 3 instructions work with a tablebut mean(), median() and sd() will not. We have to apply them to a single column:\n\nmean(fires$SPAIN)\n\n[1] 16937.24\n\nmedian(fires$SPAIN)\n\n[1] 16771\n\nsd(fires$SPAIN)\n\n[1] 5260.519\n\n\n\n\n\nSo far we have seen how to apply some of the basic statistical functions to our data, applying those functions to the data contained in the matrix or some of its columns. In the case of columns we have manually specified which one to apply a function. However, we can apply functions to all elements of an array (columns or rows) using iteration functions.\nThe apply() function allows you to apply a function to all elements of a table. We can apply some of the functions before the rows or columns of an array. There are different variants of this function. First, as always, invoke the help of the function to make sure what we are doing.\n\nhelp(apply)\n\nAccording to the specified in the function help we can see that the apply () function works as follows:\n\n💡apply(x, margin, fun, …) \n\nWhere:\n\nX: data matrix.\nMARGIN: argument to specify whether the function is applied to rows (1) or columns (2).\nFUN: function to be applied (mean,sum…)\n\nFor example, if we want to sum the values of each country/region we will do as follows:\n\napply(fires,2,mean)\n\n    YEAR PORTUGAL    SPAIN   FRANCE    ITALY   GREECE    EUMED \n 1997.00 20848.20 16937.24  4907.16  9900.64  1655.80 54249.04 \n\n\nWell, almost there. We have included the YEAR column which is the first one:\n\napply(fires[,-1],2,mean)\n\nPORTUGAL    SPAIN   FRANCE    ITALY   GREECE    EUMED \n20848.20 16937.24  4907.16  9900.64  1655.80 54249.04 \n\n\n\n📝EXERCISE 1: Calculate the total number of fires on a yearly basis.\nDeliverable: \n\nWrite a text file (.txt) with the result.\n\n\n\n📝EXERCISE 2:  Open the file “barea.csv” (file containing Burned Area by year and country) and save it in an object named “barea” - Select and store in a new matrix the data from the year 2000 to 2009. - Calculate descriptive statistics 2000-2009. - Calculate the mean, standard deviation, minimum and maximum of all columns and save it to a new object.\nDeliverable: \n\nWrite a text file (.txt) with the result.\n\n\n\n 🪄EXERCISE 2 HINT: \nUse the apply function to calculate each statistic, separately.\n\n\n\n\nWe have already seen how some of the basic functions of R. work. However, we have the possibility of extending the functionalities of R by importing new packages into our environment. These packages are developed by different research groups and/or individuals.\nThere are currently over 20015 packages available in the R project repository (CRAN). Obviously we do not need to know how each one of them works, but only focus on those that fit our needs.\n\n\nWarning: package 'rvest' was built under R version 4.3.3\n\n\nWarning: package 'ggplot2' was built under R version 4.3.3\n\n\nWarning: package 'tidyr' was built under R version 4.3.3\n\n\nWarning: package 'dplyr' was built under R version 4.3.3\n\n\n\n\n\n\n\n\n\nThe import and installation of new packages is carried out in 2 stages:\n\nobtaining and installing and internal call to the package.\nLoading the package into our session.\n\n\n\n\nWe will install the “foreign” package. This package provides functions for reading and writing data stored in different statistical software formats such as Minitab, S, SAS, SPSS, Stata, Systat … and to read and write dBase files such as attribute tables of vector layers in format shapefile. The first thing we will do is get the package via download. This can be done from the menu of R:\n\nPackages / Install packages …\nSelect download directory (mirror)\nSearch for “foreing”\n\nIf you are using RStudio simply go to the Packages tab in the lower right box and select the Install option. In the popup window select the Repository (CRAN, CRANextra) option in the drop-down menu and type the name of the package.\n\n\n\n\n\nInstalling a package using RStudio\n\n\n\n\nAnother option is to obtain the package in .zip format directly from the webpage of project R and use the function Install package (s) from local zip files … (or Package archives in RStudio).\nIt is also possible to install packages through instructions in the R window, which is the most recommended method7:\n\ninstall.packages(\"foreign\")\n\nAt this point we would have installed the package in our personal library of R. However, in order to use the functions of the new package in our R environment it is necessary to make an internal call to the package. This is generally done using the library() function8:\n\nlibrary(foreign)\n\nWarning: package 'foreign' was built under R version 4.3.3\n\n\nOnce this is done we have all the functions of the package ready to be used. All that is left is to learn how to use the functions of the package… which is easy to say but maybe not to do.\n\n\n\nSo far we have mainly seen how to use pre-designed functions either in the default installation or from other packages. However, there is the possibility of creating our own functions.\nA function is a group of instructions that takes an input or input data, and uses them to calculate other values, returning a result or product. For example, the mean() function takes as input a vector and returns as a result a numeric value that corresponds to the arithmetic mean.\nTo create our own functions we will use the object called function that constitute new functions. The usual syntax is:\n\n💡FunName &lt;- function(args){comands} \n\nWhere:\n\narguments are the arguments we want to pass to our function.\ncommands are the instructions needed to do whatever the function does.\n\nLet’s look at a simple example. We will create a function to calculate the standard deviation of a vector with numerical data. The standard deviation formula looks like this:\n\\[\n\\text{SD} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} (x_i - \\bar{x})^2}\n\\]\nWhich is essentially the square root (sqrt()) of the variance (var()):\n\ndesv &lt;- function(x){sqrt(var(x))}\n\nThe function name is desv(). This function requires a single argument (x) to be executed. Once the function is defined, it can be called and used as any other predefined function in the system.\n\ndata &lt;- 1:10\ndesv(data)\n\n[1] 3.02765\n\n\nLet’s see an example with 2 arguments. We will create a function to calculate the NDVI. The function will take as arguments two objects of vector type corresponding to the sensor Landsat TM channels 3 and 4:\n\nThe normalized difference vegetation index (NDVI) is a simple graphical indicator that can be used to analyze remote sensing measurements, typically but not necessarily from a space platform, and assess whether the target being observed contains live green vegetation or not wikipedia.org.\n\n\\[\nNDVI=\\frac{NIR-Red}{NIR+Red}\n\\]\nWhere \\(NIR\\)(y) is the near-infrarred band and \\(Red\\)(x) is the red band.\n\nndvi &lt;- function(x,y){(y-x)/(y+x)}\n\nAs we have said, once created we can use our functions in the same way as the rest of functions. This includes using the apply() function and its derived versions to iterate over rows and columns of an array or data frame.\nLet’s see an example with the function desv(), previously created applied to the data of number of fires:\n\napply(fires,2,desv)\n\n        YEAR     PORTUGAL        SPAIN       FRANCE        ITALY       GREECE \n    7.359801  9187.114305  5260.519400  1393.670265  3467.510729   496.662025 \n       EUMED \n13547.393887 \n\n\n\n\n\n\n\n\nR is not just an environment for the implementation and use of functions for statistical calculation but it is also a powerful environment for generating and displaying plots. Creating plots is besides an effective and quick way to visualize our data. By doing so we can verify whether data was correctly imported or not. However, creating graphics is also done by command-line instructions, which can sometimes be a bit tricky, especially at the beginning.\nIn R we can create many types of plots. With some packages it is also possible to generate maps similar to those created by GIS, although for the moment we will only see some basic types such as:\n\nDot charts\nLine charts\nBarplots\nHistograms\nScatterplots\n\nBefore going into detail with the specific types of graphics we will see some general concepts which apply to the majority of plots:\n\nAll graphics always require an object that contains the data to be drawn. This object is usually specified in the first argument of the function corresponding to each type of chart.\nThere are a number of arguments to manipulate axis labels or the chart title:\n\n\nmain: text with the title of our plot.\nxlab: text for x axis label.\nylab: text for y axis label.\nxlim: vector with upper and low range for the x-axis.\nylim: vector with upper and low range for the y-axis.\ncex: number indicating the aspect ratio between plot elements and text. 1 by default.\ncol: changes de color the plotted element. See http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf\nlegend(): adds a legend element describing symbology.\n\n\n\n\nThis is one of the most basic types of graphics if not the most basic one we can create. To create such a graph we will use the plot() function. Let’s look at a simple example using data from fires.csv9:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN)\n\n\n\n\n\n\n\n\nAs you can see, we are plotting data from the SPAIN column, ie, yearly fire occurrence data in Spain.\nRemember RStudio displays plots in the right-bottom window. In addition, if you need to take closer look use the Zoom button to pop-up a new plot window.\nLe’s tune up and enhance our plot. We can change the symbol type using the pch argument. You’ll find a list of symbol types (not just dot charts) at http://www.statmethods.net/advgraphs/parameters.html.\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4)\n\n\n\n\n\n\n\n\nWe can change symbol size using cex:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,cex=2)\n\n\n\n\n\n\n\n\nAnd we can change the color of the symbol with col:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,cex=2,col='red')\n\n\n\n\n\n\n\n\nThe col argument can be specified either using the color name as in the example or using its code number, hexadecimal or RGB so that col = 1, col = \"white\", and col = \"#FFFFFF\" are equivalent. In some types of symbols we can also change the color of the symbol background in addition to the symbol itself using the argument bg:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=21,cex=1,col='black',bg='red')\n\n\n\n\n\n\n\n\nThe finish our plot we will modify axis labels, add a title and a legend:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=21,cex=1,col='black',bg='red',\n     main='Number of fires in Spain',ylab = 'Number of fires',xlab = '')\n\n\n\n\n\n\n\n\nNote that we have used the xlab argument to leave the x-axis label blank. Now we add the legend. It is important you bear in mind that the legend is added with an additional command right after the plot statement. Legends in basic plots are just an image we add to an existing plot by emulating the symbol used in that plot using the legend() function:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=21,cex=1,col='black',bg='red',\n     main='Number of fires in Spain',ylab = 'Number of fires',xlab = '')\nlegend( \"topleft\" , cex = 1.3, bty = \"n\", legend = c(\"Spain\"), , text.col = c(\"black\"), col = c(\"red\") , pt.bg = c(\"red\") , pch = c(21) )\n\n\n\n\n\n\n\n\nBut, what if we want to add a second series of data? Then we proceed in a way similar to the legend() statement, but using the function points() similar to what we have seen in the plot() example. In the following code we add a second point data series with portugal:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=21,cex=1,col='black',bg='red',\n     main='Number of fires in Spain',ylab = 'Number of fires',xlab = '')\npoints(fires$PORTUGAL,pch=21,cex=1,col=\"blue\",bg=\"blue\")\n\n\n\n\n\n\n\n\nFinally, we update the legend to fit the new plot with the second series of data. To do that we simply include a second value on each argument using a vector:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=21,cex=1,col='black',bg='red',\n     main='Number of fires in Spain',ylab = 'Number of fires',xlab = '')\npoints(fires$PORTUGAL,pch=21,cex=1,col=\"blue\",bg=\"blue\")\nlegend( \"topleft\" , cex = 1.3, bty = \"n\", legend = c(\"Spain\",\"Portugal\"), , text.col = c(\"black\"), col = c(\"red\",\"blue\") , pt.bg = c(\"red\",\"blue\") , pch = c(21) )\n\n\n\n\n\n\n\n\nThe problem we are now experiencing is that data for Portugal doesn’t fit in the extent of the plot as it is. We should modify this using the xlim and ylim arguments. At this point x-axis works fine, so we’ll leave it as it is. The problem comes from y-axis. We can solve it by passing the ylim argument passing the minimum and maximum values of the fires data. We bring here some functions from Descriptive statistics and summaries.\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=21,cex=1,col='black',bg='red',\n     main='Number of fires in Spain',ylab = 'Number of fires',xlab = '',\n     ylim = c(min(fires[,2:6]),max(fires[,2:6])))\n     \npoints(fires$PORTUGAL,pch=21,cex=1,col=\"blue\",bg=\"blue\")\nlegend( \"topleft\" , cex = 1.3, bty = \"n\", legend = c(\"Spain\",\"Portugal\"), , text.col = c(\"black\"), col = c(\"red\",\"blue\") , pt.bg = c(\"red\",\"blue\") , pch = c(21) )\n\n\n\n\n\n\n\n\n\n📝EXERCISE 3:  Explain in detail how the statement ylim = c(min(fires[,2:6]),max(fires[,2:6])) works in terms of the max() and min() functions and its interaction with the firesobject.\nDeliverable: \n\nWrite a brief report describing the working procedure of the aforementioned instruction.\n\n\n\n\n\nWell, this is quite easy. In line plots we use lines to represent our data series instead of points which are the default symbol. How do we do that? Just adding an additionla argument to specify we want to use lines with type = 'l':\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,type='l',col='red')\n\n\n\n\n\n\n\n\nOf course we can change the line style:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,type='l', lty=2, col='red')\n\n\n\n\n\n\n\n\nAdding a second (or third, fourth,…,$n$) series is done with lines():\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,type='l', col='red',\n     ylim = c(min(fires[,2:6]),max(fires[,2:6])))\nlines(fires$PORTUGAL,cex=1,col=\"blue\",lty=2)\n\n\n\n\n\n\n\n\nWe now adapt the legend and add some titles and we are good to go:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,type='l', col='red',\n     main='Number of fires in Spain',ylab = 'Number of fires',xlab = '',\n     ylim = c(min(fires[,2:6]),max(fires[,2:6])))\nlines(fires$PORTUGAL,cex=1,col=\"blue\",lty=2)\n\nlegend( \"topleft\" , cex = 1.3, , lty = c(1,2), legend = c(\"Spain\",\"Portugal\"), text.col = c(\"black\"), col = c(\"red\",\"blue\"))\n\n\n\n\n\n\n\n\n\n\n\nThe next type of chart we will see is the frequency histogram. It is a bar chart that represents the number of elements of a sample (frequency) that we find within a certain range of values.\nTo draw this type of plot R uses the function hist(), which requires as a mandatory argument a vector (or column/row of an array) with the data to be represented. As with all other chart types we have seen, we can use main, xlab… Let’s see at an example using the example data from the regression.txt file10 (See Table 4.1):\n\n\n\n\n\n\n\nTavg_max: maximum average temperature in June.\nTavg: average temperature in June.\nlong: longitude in UTM values EPSG:23030.\nlot: latitude in UTM values EPSG:23030.\nd_atl: distance in meters to the Atlantic sea.\nd_medit: distance in meters to the Mediterranean sea.\nelevation: elevation above sea level in meters.\n\n\nhist(regression$elevation)\n\n\n\n\n\n\n\n\nThen we use the arguments we have seen to customize the plot:\n\nhist(regression$elevation,breaks=15,main=\"Elevation frecuency distribution\",xlab=\"Elevation\",ylab=\"Frecuency\",col=\"blue\",border=\"white\",ylim=c(0,40),xlim=c(0,2000))\n\n\n\n\n\n\n\n\nThe only new parameters are:\n\nbreaks, used to specify the number of bars in the histrogram.\nborder, used the change the color of bar’s borders.\n\n\n\n\nSo far we have seen how to construct univariate graphs, ie, represent a single variable or data series. Next we will see a type of bivariate graph, the scatterplot. This type of chart is interesting to visualize relations between two variables, almost mandatory to explore correlation or collinearity in regression analysis. Let’s look at an example with our fire data.\nIn this case we introduce in the function plot() a second data argument (\\(y\\)) with a second vector with the data right after the first data argument (\\(x\\)):\n\nplot(regression$Tavg,regression$elevation)\n\n\n\n\n\n\n\n\nNote that the first data series goes to \\(x-axis\\) and the second to the \\(y\\). Again, we can customize the appearnce and symbols similar to the regural do plot:\n\nplot(regression$elevation, regression$Tavg,\n     main='Average temperature vs elevation',ylab = 'Temperature (Celsius)', xlab = 'Elevation (m)',\n     pch=21, col='black', bg='steelblue')\n\n\n\n\n\n\n\n\nA particularly useful function in combination with scatterplots is abline() which allows to incorporate a trend line to the plot. We will further explore this later.\n\nplot(regression$elevation, regression$Tavg,\n     main='Average temperature vs elevation',ylab = 'Temperature (Celsius)', xlab = 'Elevation (m)',\n     pch=21, col='black', bg='steelblue')\nabline(lm(regression$Tavg~regression$elevation), lty=2, col='gray20',lwd=3)\n\n\n\n\n\n\n\n\nPay attention to the order in which we have introduced the \\(x\\) and \\(y\\) data in plot() and abline(). It is the opposite!!.\n\n\n\nTo finish with plot creation we will see two last possibilities. The first one is how to combine several charts in a single figure and the second how to export an image file from our graphics.\n\n\nCombining several graphs in R is possible thanks to the function par(mfrow = c(rows, columns)). Using this function we prepare the display window to include several graphs simultaneously:\n\npar(mfrow = c(2, 1),mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,type='l', col='red',\n     ylim = c(min(fires[,2:6]),max(fires[,2:6])))\nplot(fires$PORTUGAL,type='l',col=\"blue\",lty=2,\n     ylim = c(min(fires[,2:6]),max(fires[,2:6])))\n\n\n\n\n\n\n\n\n\n\n\n\nSince R runs on so many different operating systems, and supports so many different graphics formats, it’s not surprising that there are a variety of ways of saving your plots, depending on what operating system you are using, what you plan to do with the graph, and whether you’re connecting locally or remotely.\nThe first step in deciding how to save plots is to decide on the output format that you want to use. The following table lists some of the available formats, along with guidance as to when they may be useful.\nHere’s a general method11 that will work on any computer with R, regardless of operating system or the way that you are connecting.\n\nChoose the format that you want to use. In this example, I’ll save a plot as a JPG file, so I’ll use the jpeg driver.\nThe only argument that the device drivers need is the name of the file that you will use to save your graph. Remember that your plot will be stored relative to the current directory. You can find the current directory by typing getwd() at the R prompt. You may want to make adjustments to the size of the plot before saving it. Consult the help file for your selected driver to learn how.\nNow enter your plotting commands as you normally would. You will not actually see the plot - the commands are being saved to a file instead.\nWhen you’re done with your plotting commands, enter the dev.off() command. This is very important - without it you’ll get a partial plot or nothing at all. So if we wanted to save a jpg file called “rplot.jpg” containing a plot of x and y, we would type the following commands:\n\n\njpeg('rplot.jpg', width = 800, height = 600, res=100)\n\n# Here goes the plot\npar(mfrow = c(2,1),mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,type='l', col='red',\n     ylim = c(min(fires[,2:6]),max(fires[,2:6])))\nplot(fires$PORTUGAL,type='l',col=\"blue\",lty=2,\n     ylim = c(min(fires[,2:6]),max(fires[,2:6])))\n\ndev.off()\n\npng \n  2"
  },
  {
    "objectID": "index.html#what-is-r",
    "href": "index.html#what-is-r",
    "title": "Introduction to spatial statistics: Spatial Analysis with R - 111019",
    "section": "2.1 What is R?",
    "text": "2.1 What is R?\nR is an object-oriented programming language and environment for statistical computing that provides relatively simple access to a wide variety of statistical techniques (R Core Team 2016). R offers a complete programming language with which to add new methods by defining functions or automating iterative processes.\nMany statistical techniques, from the classic to the latest methodologies, are available in R, with the user in charge of locating the package that best suits their needs.\nR can be considered as an integrated set of programs for data manipulation, calculation and graphics. Among other features R allows:\n\neffective data storage and manipulation,\noperators for calculation on indexed variables,\na comprehensive, coherent and integrated collection of data analysis tools,\nplotting possibilities, which work directly on screen or printer, and\na well-developed, simple and effective programming language, including conditionals, loops, recursive functions and the possibility of inputs and outputs.\n\nR is distributed as open source software, so obtaining it is completely free.\nR is also multiplatform software which means it can be installed and used in various operating systems (OS), mainly Windows and Linux. However, the available functions and packages syntax is practically the same in any OS. From an operational point of view, R consists of a base system and additional packages that extend its functionality. Among the main types of packages we found:\n\nThose that are part of the base system.\nThose that are not part of the base system, but are recommended (survival, nlme). In GNU/Linux and Windows these packages are already part of the standard distribution.\nOther packages such as UsingR, foreing, or Maptools. These must be selected and installed individually. We will see how to do this later.\n\nThe functions included in the packages installed by default, that is, those that are predefined in the basic installation R, are available for use at any time. However, in order to use the functions of new packages, specific calls must be made to those packages.\n\n2.1.1 Getting and installing R\nThe installation of R depends on the operating system to be used. You can find all the necessary information in:\n\nhttp://cran.r-project.org/\nWindows: http://cran.r-project.org/bin/windows/\nLinux: http://cran.r-project.org/bin/linux/\n\nFor the development of this course we will use the Windows version but feel free to use whatever version fits your needs. The last version of R is downloadable from here. We will install the latest version available. Remember that you have to install the version that corresponds to the architecture of your OS (32 or 64 bits). In case of doubt install both versions or at least the 32-bit version, which will always work on our computer.\nInstallation in Windows is very simple. Just run the executable (.exe) file and follow the installation steps (basically say Yes to everything). Once R is installed, we will install RStudio an integrated development environment (IDE) that is more user-friendly than the basic R interface. RStudio provides a more complete environment and some useful tools such as:\n\nAutocomplete instructions1.\nObject management.\nData display and visualization.\nExporting plots and figures.\n\nWe will install the latest version of RStudio. You can see the installation steps in the installation video tutorial.\n\nNote that RStudio is just an interface. Any code block or instruction will work in any other R environment.\nBefore installing RStudio you need to have already installed the standard R software.\n\n\n\n2.1.2 Documentation, manuals and help\nBeing an open source software and with a strong collaborative component R has a large amount of resources and documentation relative to the specific syntax of the language itself (control structures, function creation, calls to objects …) and to every single package available as well.\nOn the other hand, R counts on a series of manuals which are available right after installing the software. You can find them in the installation directory of R (C:Files-X.X.X). These manuals and many others can also be downloaded from the R project website:\n\nWriting R extensions.\nR data import / export.\nThe R language definition.\nR installation and administration.\nAn introduction to R.\n\nFinally, in addition to the wide repertoire of manuals available, there is also a wide range of resources and online help including:\n\nhttp://www.r-bloggers.com/. A website dedicated to R development of tutorials.\nhttp://www.r-project.org/mail.html. R help mailing lists with various interest groups including the R (r-sig-geo) GIS user community.\nhttp://stackoverflow.com/. Website devoted to questions-and-answers on programming languages among which is R also available2.\nhttp://www.r-tutor.com/. A website devoted to teach statistics. An useful one if yo3u are not much familiar with basic statistical methods.\n\nIt is relatively important to become familiar from the beginning with the various alternatives for getting help. A key part of your success in using R lies in your ability to be self-relient and be able to get help and apply it to your own problems."
  },
  {
    "objectID": "index.html#starting-with-r",
    "href": "index.html#starting-with-r",
    "title": "Introduction to spatial statistics: Spatial Analysis with R - 111019",
    "section": "2.2 Starting with R",
    "text": "2.2 Starting with R\n\n2.2.1 The R environment\nR is basically a command line environment that allows the user to interact with the system to enter data, perform mathematical calculations or visualize results through plots and maps.\nFigure 1.1 shows standard appearance of the R console, which can be considered as a windows cmd like terminal or console. We have also seen what the terminal and working environment looks like in RStudio at the end of the installation process (Figure 1.2). A third possibility is to work directly on the cmd terminal (Figure 1.3). The commands and instructions are the same regardless of the environment that we chose. In this course we will focus on the use of RStudio, since it is the simplest of them all.\n\n\n\nR standard terminal\n\n\n\n\n\nRStudio interface\n\n\n\n\n\nR code terminal\n\n\nThe terminal (regardless of the chosen option) is usually the main working window and is where we will introduce the necessary instructions to carry out our operations. It is in this window where we will visualize the results from most instructions and objects we generate. An exception to this are plots and maps which are displayed in a specifically-devoted window located in the bottom-right corner."
  },
  {
    "objectID": "index.html#working-with-r",
    "href": "index.html#working-with-r",
    "title": "Introduction to spatial statistics: Spatial Analysis with R - 111019",
    "section": "2.3 Working with R",
    "text": "2.3 Working with R\nLet’s get started and insert our first command in the R’s terminal. When R is ready or awaiting us to input an instruction the terminal shows a cursor right after a &gt; symbol to indicate it.\n\n\n\n\n\nR waiting for sintructions\n\n\n\n\nAt this point it is necessary to take into account that R is an interpreted language, which means that the different instructions or functions that we specify are read and executed one by one. The procedure is more or less as follows. We introduce an instruction in the R console, the application interprets and executes it, and finally generates or returns the result.\nTo better understand this concept we will do a little test using the R console as a calculator. Open the working environment of RStudio if you did not already open it and enter the following statement and press enter:\n\n10+2\n\n[1] 12\n\n\nWhat just happened is that the R interpreter has read the instruction, in this case a simple arithmetic operation, executed it and returned the result. This is the basic way to proceed to enter operations. However, it will not be necessary for us to always enter the instructions manually. Later we will see how to create scripts or introduce blocks of instructions."
  },
  {
    "objectID": "index.html#objects-in-r",
    "href": "index.html#objects-in-r",
    "title": "Introduction to spatial statistics: Spatial Analysis with R - 111019",
    "section": "2.4 Objects in R",
    "text": "2.4 Objects in R\nWe have previously mentioned some features of R such as that R is an object-oriented language. But, what does this mean? It basically means that to perform any type of task we use objects. Everything in R is an object (functions, variables, results …). Thus, entities that are created and manipulated in R are called objects, including data, functions and other structures.\nObjects are stored and characterized by their name and content. Depending on the type of object we create that object will have a given set of characteristics. Generally the first objects one creates are those of variable type, in which we will be able to store a piece of data and information. The main objects of variable type in R are:\n\nNumber: an integer or decimal number depending on whether we specify decimal figures.\nFactor:a categorical variable or text.\nVector: a list of values of the same type.\nArray: a vector of k dimensions.\nMatrix: a particular case of array where k=2 (rows, cols).\nData.frame: table composed of vectors.\nList: vector with values of different types.\n\nObviously there are other types of objects in R. For example, another object with which we are going to familiarize ourselves is the model objects. We can create them by storing the output of executing some kind of model like a linear regression model for instance. Spatial data also fits in its particular variety of objects. Through the course we will see both models and spatial information (vector and raster).\n\n2.4.1 Creating objects\nObjects in R are created by declaring a variable by specifying its name and then assign it a value using the &lt;- operator. We can also use = but the &lt;- operator is most commonly found in examples and manuals.\nSo, to create an object and assign it a value the basic instruction is composed of object name &lt;- value.\n\nn &lt;- 4\n\nTry to introduce the following instructions to create different kind of objects:\n\nn &lt;- 15\nx &lt;- 1.0\nname &lt;- \"Marcos\"\n\nWe can also store in an object the result form any operation:\n\nn &lt;- 10+2\n\nSo here is the thing. The type of object we create depends on the content that we assign. Therefor, if we assign a numeric value, we are creating an object of type number (integer or decimal) and if we assign a text string (any quoted text, either with single or double quotes), we are creating a text type object or string. Once created, the objects are visualized using calls using the name that we have assigned to the object. That is, we will write to the terminal in the name of the object and then its value will be shown.\n\nn\n\n[1] 12\n\nname\n\n[1] \"Marcos\"\n\n\nSome considerations to keep in mind when creating objects or working with R in general lines:\n\nR is case-sensitive so radio ≠ Radio\nIf a new value is assigned to an object it is overwritten and deletes the previous value.\nTextual information (also known as string or char) is entered between quotation marks, either single ('') or double (\"\").\nThe function ls() will show us in the terminal the objects created so far.\nIf the value obtained from an instruction is not assigned in an object it is only displayed in the terminal, it is not stored.\n\n\n\n2.4.2 Vectors\nOne of the most common objects in R is the vector. A vector can store several values, which must necessarily be of the same type (all numbers, all text, and so forth). There are several ways to create vectors. Try entering the following instructions and viewing the created objects.\n\nv1 &lt;- c(1,2,3,4,5)\nv1\n\n[1] 1 2 3 4 5\n\n\n\nv2 &lt;- 1:10\n\n\nv3 &lt;- -5:3\nv3\n\n[1] -5 -4 -3 -2 -1  0  1  2  3\n\n\n\nv4 &lt;- c('spatial','statistics','rules!!')\nv4\n\n[1] \"spatial\"    \"statistics\" \"rules!!\"   \n\n\nWe have just covered the basic methods for vector creation. The most common approach is use the function c() which allow as to introduce values manually by separatting them using ,.\n\nv1 &lt;- c(1, 2, 3, 4, 5)\nv1\n\n[1] 1 2 3 4 5\n\n\n\nv4 &lt;- c('spatial','statistics','rules!!')\nv4\n\n[1] \"spatial\"    \"statistics\" \"rules!!\"   \n\n\nAnother option that only works for vectors containing integer values is the use of : which produces a ordered sequence of numbers by adding 1 starting from the first value and finishing in the last.\n\nv2 &lt;- 1:10\n\n\nv3 &lt;- -5:3\nv3\n\n[1] -5 -4 -3 -2 -1  0  1  2  3\n\n\nVectors, lists, arrays, and data frames are indexed objects. This means that they store several values and assign to each of them a numerical index that indicates their position within the object. We can access the information stored in each of the positions by using name[position]:\n\nv1[1]\n\n[1] 1\n\n\nNote that opposite to most of the other programming languages, the index for the first position in an indexed object is 1, whereas Python, C++ and others use 0.\nAs with an unindexed object, it is possible to modify the information of a particular position using the combination name[position] and the assignment operator &lt;-. For example:\n\nv3[9] &lt;- 1000000\nv3[9]\n\n[1] 1e+06\n\n\nLet’s see some specific functions and basic operations for vectors and other indexed objects:\n\nlength(vector): Returns the number of positions of a vector.\nLogical operators &lt;,&gt;, ==,!=: Applying these operators on a vector returns a new vector with values TRUE/FALSE for each of the positions of the vector, depending on whether the given values satisfies or not the condition.\n\n\nlength(v3)\n\n[1] 9\n\n\n\nv4&lt;-1:5\nv4&gt;3\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\n\n\n\n2.4.3 Lists\nOnce we have seen vectors we go to explore how objects of type list work. A list is an object similar to a vector with the difference that lists allow to store values of different type. Lists are created using the list(value1, value2, ...) function. For example:\n\nlist1 &lt;- list(1,7,\"Marcos\")\nlist1\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 7\n\n[[3]]\n[1] \"Marcos\"\n\n\nTo access the values stored in the different positions proceed in the same way we did with vectors, ie name[position]:\n\nlist1[3]\n\n[[1]]\n[1] \"Marcos\"\n\n\nWe can use the length() function with list too:\n\nlength(list1)\n\n[1] 3\n\n\n\n\n2.4.4 Arrays\nArrays are an extension of vectors, which add additional dimensions to store information. The most common case is the 2-dimensional matrix (rows and columns). To create an array, we use array(values, dimensions). Both values and dimensions are specified using vectors. In the following example we see how to create a matrix with 4 rows and 5 columns, thus containing 20 values, in this case correlative numbers from 1 to 20:\n\nmyarray&lt;- array(1:20,dim=c(4,5))\nmyarray\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    5    9   13   17\n[2,]    2    6   10   14   18\n[3,]    3    7   11   15   19\n[4,]    4    8   12   16   20\n\n\nTo access the stored values we will use a combination of row-and-column positions like matrix[row, col], where row indicates the row postition and col the column one. If we only assign value to one of the coordinates ([row,] or [,col]) we get the vector corresponding to the specified row or column.\n\nmyarray[3,2]\n\n[1] 7\n\nmyarray[3,]\n\n[1]  3  7 11 15 19\n\nmyarray[,2]\n\n[1] 5 6 7 8\n\n\n\n\n2.4.5 Data.frame\nA data frame is used for storing data tables. It is a list of vectors of equal length. For example, the following variable df is a data frame containing three vectors n, s, b.\n\nn &lt;- c(2, 3, 5) \ns &lt;- c(\"aa\", \"bb\", \"cc\") \nb &lt;- c(TRUE, FALSE, TRUE) \ndf &lt;- data.frame(n, s, b)\n\nAs you can see, the function data.frame() is used to create the data.frame. However, we will seldom use these function to create objects or store data. Normally, we will call an instruction to read text files containing data or call data objects available in some packages."
  },
  {
    "objectID": "index.html#object-management",
    "href": "index.html#object-management",
    "title": "Introduction to spatial statistics: Spatial Analysis with R - 111019",
    "section": "2.5 Object management",
    "text": "2.5 Object management\nWe have seen so far aspects related to the creation of objects. However we should be also know how many objects we have created in our session and how to remove them if necessary. To display all created objects we use ls(). Deleting objects in R is done by the command remove rm(object) and then call to the garbage collector with gc() to free-up the occupied memory.\n\nls()\n\n [1] \"b\"       \"df\"      \"list1\"   \"myarray\" \"n\"       \"name\"    \"s\"      \n [8] \"v1\"      \"v2\"      \"v3\"      \"v4\"      \"x\"      \n\n\nIf we want to removal all the objects we have currently in our working session we can pass a list object containing the names of all objects to the gc() function. If you are thinking on combining gc()and ls()you are right. This would be the way:\n\nrm(list=ls())\ngc()\n\n          used (Mb) gc trigger (Mb) max used (Mb)\nNcells  589897 31.6    1256704 67.2  1256704 67.2\nVcells 1106909  8.5    8388608 64.0  1794756 13.7"
  },
  {
    "objectID": "index.html#functions-and-arguments",
    "href": "index.html#functions-and-arguments",
    "title": "Introduction to spatial statistics: Spatial Analysis with R - 111019",
    "section": "2.6 Functions and arguments",
    "text": "2.6 Functions and arguments\nUp to this point we have seen and executed some instructions in R, generally oriented to the creation of objects or realization of simple arithmetic operations.\nHowever, we have also executed some function-type statements, such as the length() function. A function can be defined as a group of instructions that takes an input, uses this input to compute other values and returns a result or product. We will not go into very deep details, at least for now. It suffices to know that to execute a function it is enough to invoke the instruction that calls the desired function (length) and to specify the necessary inputs, also known as arguments. These inputs are always included between the parentheses of the instruction (length(vector)). If several arguments are needed we separate them using ,.\nSometimes we can refer to a given argument by using the argument’s name as is the case of the example we saw to delete all the objects in a session rm(list=ls())."
  },
  {
    "objectID": "index.html#scripts-in-r",
    "href": "index.html#scripts-in-r",
    "title": "Introduction to spatial statistics: Spatial Analysis with R - 111019",
    "section": "2.7 Scripts in R",
    "text": "2.7 Scripts in R\nSo far we have inserted instructions in the console but this is not the most efficient way to work. We will focus on the use of scripts which are an ordered set of instructions. This means we can write a text file with the instructions we want to insert and then run them at once.\nRStudio has an script development environment which opens in the top-left window. We can access the scripting window pressing File/New File/R script.\nFor additional information visit the RStudio support site."
  },
  {
    "objectID": "index.html#the-working-directory",
    "href": "index.html#the-working-directory",
    "title": "INTROR",
    "section": "2.1 The working directory",
    "text": "2.1 The working directory\nUsing data files normally requires us to specify the location of that file using paths. To avoid this, R has a tool that allow us to specify a target folder -the so-called working directory or folder- to work with.\nThe working directory is the default path for reading and writing files of any kind. We can know the path to the current working directory using the getwd() command. To set a new working directory, we use the command setwd(\"path\"). Remember that setwd() requires a string argument (whereas getwd() does not) to specify the path to the working directory (“path”).\n\ngetwd()\nsetwd('C:/Users/Marcos/Desktop/')\ngetwd()\n\nBy default, in Windows the working directory is set to the Documents folder.\nOnce the working directory is specified, everything we do in R (read files, export tables and/or graphics …) will be done in that directory. However, it is possible to work with other file system locations, specifying a different path through the arguments of some functions."
  },
  {
    "objectID": "index.html#reading-data-files",
    "href": "index.html#reading-data-files",
    "title": "INTROR",
    "section": "2.2 Reading data files",
    "text": "2.2 Reading data files\nR allows you to read any type of file in ASCII format (text files). The most frequently used functions are:\n\nread.table() and its different variations\nscan()\nread.fwf()\n\nFor the development of this course we will focus on using the read.table() function as it is quite versatile and easy to use. Before starting to use a new function we should always take a look at the available documentation. we will take this opportunity to show you how to do this in R so that you begin to become familiar R help.\nAny available function in R, regardless of being a standard one or belonging to an imported package has a documentation entry in the R help. R help describes us in detail the use of any function, providing information of the different arguments of the function, argument types, defaults, reference to the method (when applies) and even short code examples. To access the help we will use the help() function as follows:\n\nhelp(read.table)\n\nEntering the help() function we access the manual. In this case we can see a brief description of the function read.table() and its different variants (read.csv(), …). Below is the description of the arguments of the function, followed by some examples of application. This is the usual procedure for all functions available in R.\n\n\n\nHelp example\n\n\nIn case we use the regular R interface or the cmd terminal, the help entry will open in our default web browser.\nAt first glance the read.table() function seems to require many arguments, while its variations seem simpler. As already mentioned, arguments are just parameters that we can specify or change to execute a function, thus tunning the operation of the functions and the result to be obtained.\nArguments are specified within the function separated by commas (“,”). However, it is not necessary to assign a value to each one of them, since in the case of omitting an argument it is assigned a default value (always reported in the help entry). In the case of read.table() versus other functions like read.csv() the main advantage of using the first is that we can manipulate any argument, whereas most of them are fixed in the later. read.csv() is desigend to open comma separate files following the north-american standard (, as field delimiter and . as decimal separator). On the other hand, read.table() can potentially open any text file regardless of the separator, encoding, decimal format and so on so forth. Most of the executions of read.table() consist of:\n\n💡read.table(file,header=TRUE, sep=“,”,dec=“.”)\n\n\nfile: path and name of the file to open.\nheader: TRUE/FALSE argument to determine whether the first row of the data file contains column names.\nsep: field or column separator4.\ndec: decimal separator.\n\nLet’s see an example of reading file. We will read the file coordinates.txt, located in the Data directory. The file is structured in 3 columns with heading and separated by “;”. Al data are integer so no decimal separator is needed. See Table 2.2.\n\n\n\nStructure of the coordinates.txt file.\n\n\nFID_1\nX_INDEX\nY_INDEX\n\n\n\n\n364011\n82500\n4653500\n\n\n371655\n110500\n4661500\n\n\n487720\n55500\n4805500\n\n\n474504\n28500\n4783500\n\n\n436415\n85500\n4729500\n\n\n457549\n38500\n4757500\n\n\n469377\n39500\n4775500\n\n\n397162\n124500\n4687500\n\n\n434666\n41500\n4727500\n\n\n478383\n49500\n4789500\n\n\n488973\n329500\n4807500\n\n\n394153\n77500\n4684500\n\n\n426962\n36500\n4718500\n\n\n362216\n148500\n4651500\n\n\n\n\n\nThe process to follow is:\n\nSet working directory.\nUse the function to save the data in an object.\n\nIf we do…\n\nsetwd('.C/Users/Pere/INTRO_R/')\nread.table('./data/Module_1/coordinates.txt',header=TRUE,sep=';')\n\n…as we have not specified any object in which to store the result of the function, the contents of the file are simply printed on the terminal. This is a usual mistake, don’t worry. To store and later access the contents of the file we will do the following:\n\ntable&lt;-read.table('./data/Module_1/coordinates.txt',header=TRUE,sep=';')\ntable\n\n    FID_1 X_INDEX Y_INDEX\n1  364011   82500 4653500\n2  371655  110500 4661500\n3  487720   55500 4805500\n4  474504   28500 4783500\n5  436415   85500 4729500\n6  457549   38500 4757500\n7  469377   39500 4775500\n8  397162  124500 4687500\n9  434666   41500 4727500\n10 478383   49500 4789500\n11 488973  329500 4807500\n12 394153   77500 4684500\n13 426962   36500 4718500\n14 362216  148500 4651500\n\n\nPlease note that:\n\nYou have to specify your own working directory.\nThe path to the directory is specified in text format, so you type “in quotation marks”.\nThe name of the file to be read is also specified as text.\nThe header argument only accepts TRUE or FALSE values.\nThe sep argument also requires text values to enter the separator5.\nIt is advisable to save the data an object (table &lt;-).\n\nThe result of read.table() is an array stored in an object named table. Since read.table() returns an array we can manipulate our table using the same procedure described in the @ref(arrays) section.\n\ntable[,1]\n\n [1] 364011 371655 487720 474504 436415 457549 469377 397162 434666 478383\n[11] 488973 394153 426962 362216\n\ntable[1,1]\n\n[1] 364011\n\n\nBelow we found some interesting functions to preview and verify the information, and to know the structure of the data we have just imported. These functions are normally used to take a quick look into the first and last rows of an array or data.frame object and also to describe the structure of a given object.\n\nhead(): displays the first rows of the array.\ntail(): displays the last rows of the array.\nstr(): displays the structure and data type (factor or number).\n\n\nhead(table)\n\n   FID_1 X_INDEX Y_INDEX\n1 364011   82500 4653500\n2 371655  110500 4661500\n3 487720   55500 4805500\n4 474504   28500 4783500\n5 436415   85500 4729500\n6 457549   38500 4757500\n\ntail(table)\n\n    FID_1 X_INDEX Y_INDEX\n9  434666   41500 4727500\n10 478383   49500 4789500\n11 488973  329500 4807500\n12 394153   77500 4684500\n13 426962   36500 4718500\n14 362216  148500 4651500\n\nstr(table)\n\n'data.frame':   14 obs. of  3 variables:\n $ FID_1  : int  364011 371655 487720 474504 436415 457549 469377 397162 434666 478383 ...\n $ X_INDEX: int  82500 110500 55500 28500 85500 38500 39500 124500 41500 49500 ...\n $ Y_INDEX: int  4653500 4661500 4805500 4783500 4729500 4757500 4775500 4687500 4727500 4789500 ...\n\n\nAs already mentioned, read.table() is adequate to start reading of files to incorporate data into our working session in R. In any case we must be aware that there are other possibilities such as the read.csv() and read.csv2() that we have already seen when accessing the read.table() description. These functions are variations that defaults some arguments such as the field separator (columns) or the decimal character. In the help of the function you have information about it."
  },
  {
    "objectID": "index.html#writing-text-files",
    "href": "index.html#writing-text-files",
    "title": "INTROR",
    "section": "2.3 Writing text files",
    "text": "2.3 Writing text files\nOf course, we can also write text files from our data. The procedure is quite similar to read data but using write.table() instead of read.table. Remember that the created files are saved into the working directory, unless you specify an alternative path in the function arguments. As always, before starting the first thing is to consult the help of the function.\n\nhelp(\"write.table\")\n\nThe arguments of the function are similar to those already seen in read.table ():\n\n💡write.table(object,file,names,sep)\n\n\nobject: object of type matrix (or dataframe) to write.\nfile: name and path to the created file (in text format).\nrow.names: add or not (TRUE or FALSE) queue names. FALSE is recommended.\nsep: column separator (in text format).\ndec: decimal separator (in text format).\n\nTry the following instructions6 and observe the different results:\n\nwrite.table(table,'table1.txt',row.names=TRUE,sep='\\t')\nwrite.table(table,'table2.txt',row.names=FALSE,sep='\\t')\nwrite.table(table,'table3.txt',row.names=FALSE,sep=';')\nwrite.table(table,'your path/table4.txt',sep=';')\nwrite.csv(table,'your path/table5.csv')"
  },
  {
    "objectID": "index.html#data-manipulation",
    "href": "index.html#data-manipulation",
    "title": "INTROR",
    "section": "2.4 Data manipulation",
    "text": "2.4 Data manipulation\nLet’s see the most common instructions for manipulating and extracting information in R. Specifically we will see how to extract subsets of data from objects of type vector, array or dataframe. We will also see how to create new data sets from the aggregation of several objects. There are many commands that allow us to manipulate our data in R. Many things can be understood as manipulation but for the moment we will focus on:\n\nSelect or extract information\nSort tables\nAdd rows or columns to a table\n\nAs you might already guess, we will work with tabular data like arrays and data.frames which we further refer to as tables.\n\n2.4.1 Working with columns\nThe first thing we will do is access the information stored in the column(s) of a given table object. There are two basic ways to do this:\n\nUsing the position index of the column.\nUsing the name (header) of the column.\n\nThese two basic forms are not always interchangeable, so we will use one or the other depending on the case. It is recommended that you use the one that feels most comfortable for you. However, in most examples the column position index is used since it is a numerical value that is very easily integrated with loops and other iterative processes.\n\n2.4.1.1 Extracting columns\nTo extract columns using the position index we will use a series of instructions similar to those already seen in extracting information from Arrays, Vectors and Lists. The following statement returns the information of the second column of the array object table and stores it in a new object that we called col2:\n\ncol2 &lt;- table[,2]\ncol2\n\n [1]  82500 110500  55500  28500  85500  38500  39500 124500  41500  49500\n[11] 329500  77500  36500 148500\n\n\nIt is also possible to extract a range of columns, proceeding in a similar way to what has already been seen in the creation of vectors. The following statement extracts columns 2 and 3 from the table object and stores them in a new object called cols:\n\ncols &lt;- table[,2:3]\ncols\n\n   X_INDEX Y_INDEX\n1    82500 4653500\n2   110500 4661500\n3    55500 4805500\n4    28500 4783500\n5    85500 4729500\n6    38500 4757500\n7    39500 4775500\n8   124500 4687500\n9    41500 4727500\n10   49500 4789500\n11  329500 4807500\n12   77500 4684500\n13   36500 4718500\n14  148500 4651500\n\n\nNow let’s see how to select columns using their name. Name extraction is performed using a combination of object and column name object using $ to separte object from column name. The following statement selects the column named Y_INDEX from the array object table and stores it in col.Y_INDEX:\n\ncol.Y_INDEX &lt;- table$Y_INDEX\ncol.Y_INDEX\n\n [1] 4653500 4661500 4805500 4783500 4729500 4757500 4775500 4687500 4727500\n[10] 4789500 4807500 4684500 4718500 4651500\n\n\nA key piece of information here is the name of the column which we need to know in advance. Well, we can check the original text file or inspect the object table using str(). We can also take look to the top-right window activaing the Environment sub-window and unwrap table but be aware this can be only accessed using RStudio.\nThe main difference between these two methods is that index selection makes it possible to extract column ranges easily. To do this using the name of the columns you have to use functions like subset():\n\ncols2 &lt;- subset(table, select = c(X_INDEX,Y_INDEX))\n\nUsing the argument select we can point the columns that we want to extract using a vector with column names. Using subset() it is also possible to specify the columns that we do NOT want to extract. To do this proceed as follows:\n\ncols2 &lt;- subset(table, select = -c(X_INDEX,Y_INDEX))\n\nIn this way we would only extract the first column, excluding X_INDEX and Y_INDEX. Of cours, we can do this using the column index as well:\n\ncols2 &lt;- table[,-(2:3)]\n\n\n\n2.4.1.2 Merge columns and tables\nThe main reason why we are learning how to manipulate table columns is to be able to prepare our data for other purposes. It may be the case we need to join tables or columns that proceed from the same original table. The instruction cbind() allow us to merge together several tables and/or vectors provided they have the same number of rows. We can merge as many objects as we want to, by separating them using ,:\n\ncols3 &lt;- cbind(col2,cols2)\ncols3\n\n        col2  cols2\n [1,]  82500 364011\n [2,] 110500 371655\n [3,]  55500 487720\n [4,]  28500 474504\n [5,]  85500 436415\n [6,]  38500 457549\n [7,]  39500 469377\n [8,] 124500 397162\n [9,]  41500 434666\n[10,]  49500 478383\n[11,] 329500 488973\n[12,]  77500 394153\n[13,]  36500 426962\n[14,] 148500 362216\n\n\n\n\n2.4.1.3 Changing column names\nIt is often the case we need to alter or change the name of a table object. If we wanted to rename all the columns of an object we would to pass a vector with names to the function colnames() in case we are renaming an array or names() if we are dealing with a data.frame. Note that the vector should have the same length as the total number of columns. Lets rename our table cols3:\n\ncolnames(cols3)&lt;- c(\"COL1\",\"COL2\")\n\nWhat if we want to change only a given name. Then we just point to the column header using the position index like this:\n\ncolnames(cols3)[2]&lt;- \"RENAMED COLUMN\"\n\nYou may be wondering How can we know what kind of object is my table?. That is a very good question. Specially at the begining is quite difficult to be in control this stuff. If you use RStudio you already see a description of the objects in the top-right window. array or matrix objects show something like [1:14,1:2] indicating multiple dimensions, vectors are similar but with only 1 dimension [1:14] and data.frames show the word data.frame in their description. However, this is not the fancy way to deal with object types. Just for the record, when we mean type an actual code developer means class. Of course there is a function called class() that returns the class an object belongs to:\n\nclass(cols3)\n\n[1] \"matrix\" \"array\" \n\n\n\n\n2.4.1.4 Sorting our data\nFinally, let’s look at how to sort columns and arrays. To sort a column in R, the sort() function is used. The general function of the function is:\n\nsort(cols3[,1])\n\n [1]  28500  36500  38500  39500  41500  49500  55500  77500  82500  85500\n[11] 110500 124500 148500 329500\n\n\nIf we want to reorder an array based on the values of one of its columns, we will use the order () function. The general operation of the function is:\n\ntable[order(table$X_INDEX),]\n\n    FID_1 X_INDEX Y_INDEX\n4  474504   28500 4783500\n13 426962   36500 4718500\n6  457549   38500 4757500\n7  469377   39500 4775500\n9  434666   41500 4727500\n10 478383   49500 4789500\n3  487720   55500 4805500\n12 394153   77500 4684500\n1  364011   82500 4653500\n5  436415   85500 4729500\n2  371655  110500 4661500\n8  397162  124500 4687500\n14 362216  148500 4651500\n11 488973  329500 4807500\n\n\nTo be honest, in this last example we are actually working with rows. Take a look at the position of the ,. The brackets are also something that we will use later to extract data from a table. But it feels right to bring here the order() command right after sort().\n\n\n\n2.4.2 Working with rows\nLet us now turn to the manipulation of rows. The procedure is basically the same as in the case of columns, except for the fact that we normally do not work with names assigned to rows (although that’s a possibility), but we refer to a row using its position. To extract rows or combine several objects according to their rows we use the following expressions:\n\nrow1 &lt;- table[1:5,]\nrow2 &lt;- table[-(6:7),]\nrow3 &lt;- rbind(row1,row2)\n\nSame as with Arrays we point to rows instead of columns when we use the index value to the left of the [row,col]. So that’s the thing, we just change that and we are dealing with rows. We can join rows and tables using the rbind() function rather than cbind(). r stands for row and c for column.\nWe can extract a subsample of rows that meet a given criteria:\n\n💡table[criteria,]\n\n\ntable[table$X_INDEX==82500,]\n\n   FID_1 X_INDEX Y_INDEX\n1 364011   82500 4653500\n\ntable[table$X_INDEX&gt;82500,]\n\n    FID_1 X_INDEX Y_INDEX\n2  371655  110500 4661500\n5  436415   85500 4729500\n8  397162  124500 4687500\n11 488973  329500 4807500\n14 362216  148500 4651500\n\n\nOh, we expect you to have found out this by yourself but evidently we can combine row and column manipulation if that fits our purpose."
  },
  {
    "objectID": "index.html#descriptive-statistics-and-summaries",
    "href": "index.html#descriptive-statistics-and-summaries",
    "title": "INTROR",
    "section": "3.1 Descriptive statistics and summaries",
    "text": "3.1 Descriptive statistics and summaries\nThere are a large number of functions in the basic installation of R. It would be practically impossible to see all of them so we will see some of the most used, although we must remember that not only is there the possibility of using predesigned functions, but R also offers the possibility to create your own functions.\nBelow are some of the basic statistical functions that we can find in R. These functions are generally applied matrix-array or data.frame data objects. Some of them can be applied to the whole table and others to single columns or rows.\n\nsum() Add values.\nmax() Returns the maximum value.\nmin() Returns the minimum value.\nmean() Calculates the mean.\nmedian() Returns the median.\nsd() Calculates the standard deviation.\nsummary() Returns a statistical summary of the columns.\n\nWe are going to apply them using some example data. We will use the data stored in the file fires.csv, inside the Data folder (Table 3.1). This file contains data on the annual number of fires between 1985 and 2009 in several European countries.\n\nfires &lt;- read.csv2(\"C:/Users/pjgel/OneDrive - udl.cat/Sync/Docencia/altres/INTRO_R/data/Module_1/fires.csv\",header=TRUE)\nknitr::kable(coords,caption = \"Structure of the fires.csv file.\")\n\n\nStructure of the fires.csv file.\n\n\nFID_1\nX_INDEX\nY_INDEX\n\n\n\n\n364011\n82500\n4653500\n\n\n371655\n110500\n4661500\n\n\n487720\n55500\n4805500\n\n\n474504\n28500\n4783500\n\n\n436415\n85500\n4729500\n\n\n457549\n38500\n4757500\n\n\n469377\n39500\n4775500\n\n\n397162\n124500\n4687500\n\n\n434666\n41500\n4727500\n\n\n478383\n49500\n4789500\n\n\n488973\n329500\n4807500\n\n\n394153\n77500\n4684500\n\n\n426962\n36500\n4718500\n\n\n362216\n148500\n4651500\n\n\n\n\n\nThe first thing is to import the file into a table.\n\nfires &lt;- read.table(\"C:/Users/pjgel/OneDrive - udl.cat/Sync/Docencia/altres/INTRO_R/data/Module_1/fires.csv\",header=TRUE,sep=',')\n\nOnce data is imported we can take a look at the structure to make sure that everything went well. We should have integer values for each region:\n\nstr(fires)\n\n'data.frame':   25 obs. of  7 variables:\n $ YEAR    : int  1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 ...\n $ PORTUGAL: int  8441 5036 7705 6131 21896 10745 14327 14954 16101 19983 ...\n $ SPAIN   : int  12238 7570 8679 9247 20811 12913 13531 15955 14254 19263 ...\n $ FRANCE  : int  6249 4353 3043 2837 6763 5881 3888 4002 4769 4618 ...\n $ ITALY   : int  18664 9398 11972 13588 9669 14477 11965 14641 14412 11588 ...\n $ GREECE  : int  1442 1082 1266 1898 1284 1322 858 2582 2406 1763 ...\n $ EUMED   : int  47034 27439 32665 33701 60423 45338 44569 52134 51942 57215 ...\n\n\nNow we will calculate some descriptive statistics for each column to have a first approximation to the distribution of our data. To do this we will use the function summary() that will return some basic statistical values such as:\n\nQuantile\nMean\nMedian\nMaximum\nMinimum\n\n\nsummary(fires)\n\n      YEAR         PORTUGAL         SPAIN           FRANCE         ITALY      \n Min.   :1985   Min.   : 5036   Min.   : 7570   Min.   :2781   Min.   : 4601  \n 1st Qu.:1991   1st Qu.:14327   1st Qu.:12913   1st Qu.:4002   1st Qu.: 7134  \n Median :1997   Median :21870   Median :16771   Median :4618   Median : 9540  \n Mean   :1997   Mean   :20848   Mean   :16937   Mean   :4907   Mean   : 9901  \n 3rd Qu.:2003   3rd Qu.:26488   3rd Qu.:20811   3rd Qu.:6249   3rd Qu.:11965  \n Max.   :2009   Max.   :35697   Max.   :25827   Max.   :8005   Max.   :18664  \n     GREECE         EUMED      \n Min.   : 858   Min.   :27439  \n 1st Qu.:1322   1st Qu.:45623  \n Median :1486   Median :55215  \n Mean   :1656   Mean   :54249  \n 3rd Qu.:1898   3rd Qu.:62399  \n Max.   :2582   Max.   :75382  \n\n\nThe summary() function is not only used to obtain summaries of data through descriptive statistics, but can also be used in model type objects to obtain a statistical summary of the results, coefficients, significance … Later we will see an example of this applied on a linear regression model.\nLet’s now see what happens if we apply some of the functions presented above. Try running the following instructions:\n\nsum(fires)\n\n[1] 2762377\n\nmax(fires)\n\n[1] 75382\n\nmin(fires)\n\n[1] 858\n\n\nAs can be seen these 3 instructions work with a tablebut mean(), median() and sd() will not. We have to apply them to a single column:\n\nmean(fires$SPAIN)\n\n[1] 16937.24\n\nmedian(fires$SPAIN)\n\n[1] 16771\n\nsd(fires$SPAIN)\n\n[1] 5260.519"
  },
  {
    "objectID": "index.html#the-apply-function",
    "href": "index.html#the-apply-function",
    "title": "INTROR",
    "section": "3.2 The apply() function",
    "text": "3.2 The apply() function\nSo far we have seen how to apply some of the basic statistical functions to our data, applying those functions to the data contained in the matrix or some of its columns. In the case of columns we have manually specified which one to apply a function. However, we can apply functions to all elements of an array (columns or rows) using iteration functions.\nThe apply() function allows you to apply a function to all elements of a table. We can apply some of the functions before the rows or columns of an array. There are different variants of this function. First, as always, invoke the help of the function to make sure what we are doing.\n\nhelp(apply)\n\nAccording to the specified in the function help we can see that the apply () function works as follows:\n\n💡apply(x, margin, fun, …) \n\nWhere:\n\nX: data matrix.\nMARGIN: argument to specify whether the function is applied to rows (1) or columns (2).\nFUN: function to be applied (mean,sum…)\n\nFor example, if we want to sum the values of each country/region we will do as follows:\n\napply(fires,2,mean)\n\n    YEAR PORTUGAL    SPAIN   FRANCE    ITALY   GREECE    EUMED \n 1997.00 20848.20 16937.24  4907.16  9900.64  1655.80 54249.04 \n\n\nWell, almost there. We have included the YEAR column which is the first one:\n\napply(fires[,-1],2,mean)\n\nPORTUGAL    SPAIN   FRANCE    ITALY   GREECE    EUMED \n20848.20 16937.24  4907.16  9900.64  1655.80 54249.04 \n\n\n\n📝EXERCISE 1: Calculate the total number of fires on a yearly basis.\nDeliverable: \n\nWrite a text file (.txt) with the result.\n\n\n\n📝EXERCISE 2:  Open the file “barea.csv” (file containing Burned Area by year and country) and save it in an object named “barea” - Select and store in a new matrix the data from the year 2000 to 2009. - Calculate descriptive statistics 2000-2009. - Calculate the mean, standard deviation, minimum and maximum of all columns and save it to a new object.\nDeliverable: \n\nWrite a text file (.txt) with the result.\n\n\n\n 🪄EXERCISE 2 HINT: \nUse the apply function to calculate each statistic, separately."
  },
  {
    "objectID": "index.html#installing-packages",
    "href": "index.html#installing-packages",
    "title": "INTROR",
    "section": "3.3 Installing packages",
    "text": "3.3 Installing packages\nWe have already seen how some of the basic functions of R. work. However, we have the possibility of extending the functionalities of R by importing new packages into our environment. These packages are developed by different research groups and/or individuals.\nThere are currently over 20015 packages available in the R project repository (CRAN). Obviously we do not need to know how each one of them works, but only focus on those that fit our needs.\n\n\nWarning: package 'rvest' was built under R version 4.3.3\n\n\n\nAttaching package: 'lubridate'\n\n\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n\n\nWarning: package 'ggplot2' was built under R version 4.3.3\n\n\nWarning: package 'tidyr' was built under R version 4.3.3\n\n\nWarning: package 'dplyr' was built under R version 4.3.3\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr   1.1.4     ✔ readr   2.1.5\n✔ forcats 1.0.0     ✔ stringr 1.5.1\n✔ ggplot2 3.5.1     ✔ tibble  3.2.1\n✔ purrr   1.0.2     ✔ tidyr   1.3.1\n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter()         masks stats::filter()\n✖ readr::guess_encoding() masks rvest::guess_encoding()\n✖ dplyr::lag()            masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nThe import and installation of new packages is carried out in 2 stages:\n\nobtaining and installing and internal call to the package.\nLoading the package into our session.\n\n\n3.3.1 Installing an external package\nWe will install the “foreign” package. This package provides functions for reading and writing data stored in different statistical software formats such as Minitab, S, SAS, SPSS, Stata, Systat … and to read and write dBase files such as attribute tables of vector layers in format shapefile. The first thing we will do is get the package via download. This can be done from the menu of R:\n\nPackages / Install packages …\nSelect download directory (mirror)\nSearch for “foreing”\n\nIf you are using RStudio simply go to the Packages tab in the lower right box and select the Install option. In the popup window select the Repository (CRAN, CRANextra) option in the drop-down menu and type the name of the package.\n\n\n\n\n\nInstalling a package using RStudio\n\n\n\n\nAnother option is to obtain the package in .zip format directly from the webpage of project R and use the function Install package (s) from local zip files … (or Package archives in RStudio).\nIt is also possible to install packages through instructions in the R window, which is the most recommended method7:\n\ninstall.packages(\"foreign\")\n\nAt this point we would have installed the package in our personal library of R. However, in order to use the functions of the new package in our R environment it is necessary to make an internal call to the package. This is generally done using the library() function8:\n\nlibrary(foreign)\n\nWarning: package 'foreign' was built under R version 4.3.3\n\n\nOnce this is done we have all the functions of the package ready to be used. All that is left is to learn how to use the functions of the package… which is easy to say but maybe not to do."
  },
  {
    "objectID": "index.html#create-a-function",
    "href": "index.html#create-a-function",
    "title": "INTROR",
    "section": "3.4 Create a function",
    "text": "3.4 Create a function\nSo far we have mainly seen how to use pre-designed functions either in the default installation or from other packages. However, there is the possibility of creating our own functions.\nA function is a group of instructions that takes an input or input data, and uses them to calculate other values, returning a result or product. For example, the mean() function takes as input a vector and returns as a result a numeric value that corresponds to the arithmetic mean.\nTo create our own functions we will use the object called function that constitute new functions. The usual syntax is:\n\n💡FunName &lt;- function(args){comands} \n\nWhere:\n\narguments are the arguments we want to pass to our function.\ncommands are the instructions needed to do whatever the function does.\n\nLet’s look at a simple example. We will create a function to calculate the standard deviation of a vector with numerical data. The standard deviation formula looks like this:\n\\[\n\\text{SD} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} (x_i - \\bar{x})^2}\n\\]\nWhich is essentially the square root (sqrt()) of the variance (var()):\n\ndesv &lt;- function(x){sqrt(var(x))}\n\nThe function name is desv(). This function requires a single argument (x) to be executed. Once the function is defined, it can be called and used as any other predefined function in the system.\n\ndata &lt;- 1:10\ndesv(data)\n\n[1] 3.02765\n\n\nLet’s see an example with 2 arguments. We will create a function to calculate the NDVI. The function will take as arguments two objects of vector type corresponding to the sensor Landsat TM channels 3 and 4:\n\nThe normalized difference vegetation index (NDVI) is a simple graphical indicator that can be used to analyze remote sensing measurements, typically but not necessarily from a space platform, and assess whether the target being observed contains live green vegetation or not wikipedia.org.\n\n\\[\nNDVI=\\frac{NIR-Red}{NIR+Red}\n\\]\nWhere \\(NIR\\)(y) is the near-infrarred band and \\(Red\\)(x) is the red band.\n\nndvi &lt;- function(x,y){(y-x)/(y+x)}\n\nAs we have said, once created we can use our functions in the same way as the rest of functions. This includes using the apply() function and its derived versions to iterate over rows and columns of an array or data frame.\nLet’s see an example with the function desv(), previously created applied to the data of number of fires:\n\napply(fires,2,desv)\n\n        YEAR     PORTUGAL        SPAIN       FRANCE        ITALY       GREECE \n    7.359801  9187.114305  5260.519400  1393.670265  3467.510729   496.662025 \n       EUMED \n13547.393887"
  },
  {
    "objectID": "index.html#basic-plots",
    "href": "index.html#basic-plots",
    "title": "INTROR",
    "section": "4.1 Basic plots",
    "text": "4.1 Basic plots\nR is not just an environment for the implementation and use of functions for statistical calculation but it is also a powerful environment for generating and displaying plots. Creating plots is besides an effective and quick way to visualize our data. By doing so we can verify whether data was correctly imported or not. However, creating graphics is also done by command-line instructions, which can sometimes be a bit tricky, especially at the beginning.\nIn R we can create many types of plots. With some packages it is also possible to generate maps similar to those created by GIS, although for the moment we will only see some basic types such as:\n\nDot charts\nLine charts\nBarplots\nHistograms\nScatterplots\n\nBefore going into detail with the specific types of graphics we will see some general concepts which apply to the majority of plots:\n\nAll graphics always require an object that contains the data to be drawn. This object is usually specified in the first argument of the function corresponding to each type of chart.\nThere are a number of arguments to manipulate axis labels or the chart title:\n\n\nmain: text with the title of our plot.\nxlab: text for x axis label.\nylab: text for y axis label.\nxlim: vector with upper and low range for the x-axis.\nylim: vector with upper and low range for the y-axis.\ncex: number indicating the aspect ratio between plot elements and text. 1 by default.\ncol: changes de color the plotted element. See http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf\nlegend(): adds a legend element describing symbology.\n\n\n4.1.1 Dot or point plots\nThis is one of the most basic types of graphics if not the most basic one we can create. To create such a graph we will use the plot() function. Let’s look at a simple example using data from fires.csv9:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN)\n\n\n\n\n\n\n\n\nAs you can see, we are plotting data from the SPAIN column, ie, yearly fire occurrence data in Spain.\nRemember RStudio displays plots in the right-bottom window. In addition, if you need to take closer look use the Zoom button to pop-up a new plot window.\nLe’s tune up and enhance our plot. We can change the symbol type using the pch argument. You’ll find a list of symbol types (not just dot charts) at http://www.statmethods.net/advgraphs/parameters.html.\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4)\n\n\n\n\n\n\n\n\nWe can change symbol size using cex:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,cex=2)\n\n\n\n\n\n\n\n\nAnd we can change the color of the symbol with col:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,cex=2,col='red')\n\n\n\n\n\n\n\n\nThe col argument can be specified either using the color name as in the example or using its code number, hexadecimal or RGB so that col = 1, col = \"white\", and col = \"#FFFFFF\" are equivalent. In some types of symbols we can also change the color of the symbol background in addition to the symbol itself using the argument bg:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=21,cex=1,col='black',bg='red')\n\n\n\n\n\n\n\n\nThe finish our plot we will modify axis labels, add a title and a legend:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=21,cex=1,col='black',bg='red',\n     main='Number of fires in Spain',ylab = 'Number of fires',xlab = '')\n\n\n\n\n\n\n\n\nNote that we have used the xlab argument to leave the x-axis label blank. Now we add the legend. It is important you bear in mind that the legend is added with an additional command right after the plot statement. Legends in basic plots are just an image we add to an existing plot by emulating the symbol used in that plot using the legend() function:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=21,cex=1,col='black',bg='red',\n     main='Number of fires in Spain',ylab = 'Number of fires',xlab = '')\nlegend( \"topleft\" , cex = 1.3, bty = \"n\", legend = c(\"Spain\"), , text.col = c(\"black\"), col = c(\"red\") , pt.bg = c(\"red\") , pch = c(21) )\n\n\n\n\n\n\n\n\nBut, what if we want to add a second series of data? Then we proceed in a way similar to the legend() statement, but using the function points() similar to what we have seen in the plot() example. In the following code we add a second point data series with portugal:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=21,cex=1,col='black',bg='red',\n     main='Number of fires in Spain',ylab = 'Number of fires',xlab = '')\npoints(fires$PORTUGAL,pch=21,cex=1,col=\"blue\",bg=\"blue\")\n\n\n\n\n\n\n\n\nFinally, we update the legend to fit the new plot with the second series of data. To do that we simply include a second value on each argument using a vector:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=21,cex=1,col='black',bg='red',\n     main='Number of fires in Spain',ylab = 'Number of fires',xlab = '')\npoints(fires$PORTUGAL,pch=21,cex=1,col=\"blue\",bg=\"blue\")\nlegend( \"topleft\" , cex = 1.3, bty = \"n\", legend = c(\"Spain\",\"Portugal\"), , text.col = c(\"black\"), col = c(\"red\",\"blue\") , pt.bg = c(\"red\",\"blue\") , pch = c(21) )\n\n\n\n\n\n\n\n\nThe problem we are now experiencing is that data for Portugal doesn’t fit in the extent of the plot as it is. We should modify this using the xlim and ylim arguments. At this point x-axis works fine, so we’ll leave it as it is. The problem comes from y-axis. We can solve it by passing the ylim argument passing the minimum and maximum values of the fires data. We bring here some functions from Descriptive statistics and summaries.\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=21,cex=1,col='black',bg='red',\n     main='Number of fires in Spain',ylab = 'Number of fires',xlab = '',\n     ylim = c(min(fires[,2:6]),max(fires[,2:6])))\n     \npoints(fires$PORTUGAL,pch=21,cex=1,col=\"blue\",bg=\"blue\")\nlegend( \"topleft\" , cex = 1.3, bty = \"n\", legend = c(\"Spain\",\"Portugal\"), , text.col = c(\"black\"), col = c(\"red\",\"blue\") , pt.bg = c(\"red\",\"blue\") , pch = c(21) )\n\n\n\n\n\n\n\n\n\n📝EXERCISE 3:  Explain in detail how the statement ylim = c(min(fires[,2:6]),max(fires[,2:6])) works in terms of the max() and min() functions and its interaction with the firesobject.\nDeliverable: \n\nWrite a brief report describing the working procedure of the aforementioned instruction.\n\n\n\n\n4.1.2 Line plots\nWell, this is quite easy. In line plots we use lines to represent our data series instead of points which are the default symbol. How do we do that? Just adding an additionla argument to specify we want to use lines with type = 'l':\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,type='l',col='red')\n\n\n\n\n\n\n\n\nOf course we can change the line style:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,type='l', lty=2, col='red')\n\n\n\n\n\n\n\n\nAdding a second (or third, fourth,…,$n$) series is done with lines():\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,type='l', col='red',\n     ylim = c(min(fires[,2:6]),max(fires[,2:6])))\nlines(fires$PORTUGAL,cex=1,col=\"blue\",lty=2)\n\n\n\n\n\n\n\n\nWe now adapt the legend and add some titles and we are good to go:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,type='l', col='red',\n     main='Number of fires in Spain',ylab = 'Number of fires',xlab = '',\n     ylim = c(min(fires[,2:6]),max(fires[,2:6])))\nlines(fires$PORTUGAL,cex=1,col=\"blue\",lty=2)\n\nlegend( \"topleft\" , cex = 1.3, , lty = c(1,2), legend = c(\"Spain\",\"Portugal\"), text.col = c(\"black\"), col = c(\"red\",\"blue\"))"
  },
  {
    "objectID": "index.html#histograms",
    "href": "index.html#histograms",
    "title": "INTROR",
    "section": "4.2 Histograms",
    "text": "4.2 Histograms\nThe next type of chart we will see is the frequency histogram. It is a bar chart that represents the number of elements of a sample (frequency) that we find within a certain range of values.\nTo draw this type of plot R uses the function hist(), which requires as a mandatory argument a vector (or column/row of an array) with the data to be represented. As with all other chart types we have seen, we can use main, xlab… Let’s see at an example using the example data from the regression.txt file10 (See Table 4.1):\n\n\n\n\n\n\n\nTavg_max: maximum average temperature in June.\nTavg: average temperature in June.\nlong: longitude in UTM values EPSG:23030.\nlot: latitude in UTM values EPSG:23030.\nd_atl: distance in meters to the Atlantic sea.\nd_medit: distance in meters to the Mediterranean sea.\nelevation: elevation above sea level in meters.\n\n\nhist(regression$elevation)\n\n\n\n\n\n\n\n\nThen we use the arguments we have seen to customize the plot:\n\nhist(regression$elevation,breaks=15,main=\"Elevation frecuency distribution\",xlab=\"Elevation\",ylab=\"Frecuency\",col=\"blue\",border=\"white\",ylim=c(0,40),xlim=c(0,2000))\n\n\n\n\n\n\n\n\nThe only new parameters are:\n\nbreaks, used to specify the number of bars in the histrogram.\nborder, used the change the color of bar’s borders."
  },
  {
    "objectID": "index.html#scatterplots",
    "href": "index.html#scatterplots",
    "title": "INTROR",
    "section": "4.3 Scatterplots",
    "text": "4.3 Scatterplots\nSo far we have seen how to construct univariate graphs, ie, represent a single variable or data series. Next we will see a type of bivariate graph, the scatterplot. This type of chart is interesting to visualize relations between two variables, almost mandatory to explore correlation or collinearity in regression analysis. Let’s look at an example with our fire data.\nIn this case we introduce in the function plot() a second data argument (\\(y\\)) with a second vector with the data right after the first data argument (\\(x\\)):\n\nplot(regression$Tavg,regression$elevation)\n\n\n\n\n\n\n\n\nNote that the first data series goes to \\(x-axis\\) and the second to the \\(y\\). Again, we can customize the appearnce and symbols similar to the regural do plot:\n\nplot(regression$elevation, regression$Tavg,\n     main='Average temperature vs elevation',ylab = 'Temperature (Celsius)', xlab = 'Elevation (m)',\n     pch=21, col='black', bg='steelblue')\n\n\n\n\n\n\n\n\nA particularly useful function in combination with scatterplots is abline() which allows to incorporate a trend line to the plot. We will further explore this later.\n\nplot(regression$elevation, regression$Tavg,\n     main='Average temperature vs elevation',ylab = 'Temperature (Celsius)', xlab = 'Elevation (m)',\n     pch=21, col='black', bg='steelblue')\nabline(lm(regression$Tavg~regression$elevation), lty=2, col='gray20',lwd=3)\n\n\n\n\n\n\n\n\nPay attention to the order in which we have introduced the \\(x\\) and \\(y\\) data in plot() and abline(). It is the opposite!!."
  },
  {
    "objectID": "index.html#multiple-plots",
    "href": "index.html#multiple-plots",
    "title": "INTROR",
    "section": "4.4 Multiple plots",
    "text": "4.4 Multiple plots\nTo finish with plot creation we will see two last possibilities. The first one is how to combine several charts in a single figure and the second how to export an image file from our graphics.\n\n4.4.1 Create a combined plot\nCombining several graphs in R is possible thanks to the function par(mfrow = c(rows, columns)). Using this function we prepare the display window to include several graphs simultaneously:\n\npar(mfrow = c(2, 1),mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,type='l', col='red',\n     ylim = c(min(fires[,2:6]),max(fires[,2:6])))\nplot(fires$PORTUGAL,type='l',col=\"blue\",lty=2,\n     ylim = c(min(fires[,2:6]),max(fires[,2:6])))\n\n\n\n\n\n\n\n\n\n\n4.4.2 Export an image file\nSince R runs on so many different operating systems, and supports so many different graphics formats, it’s not surprising that there are a variety of ways of saving your plots, depending on what operating system you are using, what you plan to do with the graph, and whether you’re connecting locally or remotely.\nThe first step in deciding how to save plots is to decide on the output format that you want to use. The following table lists some of the available formats, along with guidance as to when they may be useful.\nHere’s a general method11 that will work on any computer with R, regardless of operating system or the way that you are connecting.\n\nChoose the format that you want to use. In this example, I’ll save a plot as a JPG file, so I’ll use the jpeg driver.\nThe only argument that the device drivers need is the name of the file that you will use to save your graph. Remember that your plot will be stored relative to the current directory. You can find the current directory by typing getwd() at the R prompt. You may want to make adjustments to the size of the plot before saving it. Consult the help file for your selected driver to learn how.\nNow enter your plotting commands as you normally would. You will not actually see the plot - the commands are being saved to a file instead.\nWhen you’re done with your plotting commands, enter the dev.off() command. This is very important - without it you’ll get a partial plot or nothing at all. So if we wanted to save a jpg file called “rplot.jpg” containing a plot of x and y, we would type the following commands:\n\n\njpeg('rplot.jpg', width = 800, height = 600, res=100)\n\n# Here goes the plot\npar(mfrow = c(2,1),mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,type='l', col='red',\n     ylim = c(min(fires[,2:6]),max(fires[,2:6])))\nplot(fires$PORTUGAL,type='l',col=\"blue\",lty=2,\n     ylim = c(min(fires[,2:6]),max(fires[,2:6])))\n\ndev.off()\n\npng \n  2"
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Introduction to spatial statistics: Spatial Analysis with R - 111019",
    "section": "References",
    "text": "References\nR Core Team. 2021. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/."
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Introduction to spatial statistics: Spatial Analysis with R - 111019",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThis is probably the most useful one. The IDE will suggest the function name instead of fully typing it↩︎↩︎\nJust for the record, this is my favourite one↩︎↩︎\nDo not mistake it with the R vector object, they are quite different!↩︎\nuse \\t for tab↩︎\nthe same applies for dec↩︎\nRemember to adapt the path to your own folder structure↩︎\nDo not forget quotes sorrounding the name of the package↩︎\nNote that quotes are not needed↩︎\nplease, ignore the par() statement at this time↩︎\nRemember to import the file properly, setting the adequate parameters for field and decimal separator↩︎\nTaken from https://www.stat.berkeley.edu/classes/s133/saving.html↩︎"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This document constitutes the manual for the course on Introduction to spatial statistics: Spatial Analysis with R - 111019 of the European Master’s Degree in Forestry.\nThis course covers the basics of R usage, an introduction to plotting and mapping and the essential concepts of spatial data management and modeling. The course focuses on several regression and classification algorithms (Multiple Linear Regression, Generalized Linear Models, CART and Random Forest), also exploring classic interpolation methods (Inverse Distance Weighting and Kriging).\nFor any questions regarding the materials or contents of this manual please contact with rmarcos@unizar.es or perejoan.gelabert@udl.cat."
  },
  {
    "objectID": "index.html#basic-instructions",
    "href": "index.html#basic-instructions",
    "title": "Introduction to spatial statistics: Spatial Analysis with R - 111019",
    "section": "2.9 Basic instructions",
    "text": "2.9 Basic instructions\n\n2.9.1 Descriptive statistics and summaries\nThere are a large number of functions in the basic installation of R. It would be practically impossible to see all of them so we will see some of the most used, although we must remember that not only is there the possibility of using predesigned functions, but R also offers the possibility to create your own functions.\nBelow are some of the basic statistical functions that we can find in R. These functions are generally applied matrix-array or data.frame data objects. Some of them can be applied to the whole table and others to single columns or rows.\n\nsum() Add values.\nmax() Returns the maximum value.\nmin() Returns the minimum value.\nmean() Calculates the mean.\nmedian() Returns the median.\nsd() Calculates the standard deviation.\nsummary() Returns a statistical summary of the columns.\n\nWe are going to apply them using some example data. We will use the data stored in the file fires.csv, inside the Data folder (Table 3.1). This file contains data on the annual number of fires between 1985 and 2009 in several European countries.\n\nfires &lt;- read.csv2(\"./data/Module_1/fires.csv\",header=TRUE)\nknitr::kable(coords,caption = \"Structure of the fires.csv file.\")\n\n\nStructure of the fires.csv file.\n\n\nFID_1\nX_INDEX\nY_INDEX\n\n\n\n\n364011\n82500\n4653500\n\n\n371655\n110500\n4661500\n\n\n487720\n55500\n4805500\n\n\n474504\n28500\n4783500\n\n\n436415\n85500\n4729500\n\n\n457549\n38500\n4757500\n\n\n469377\n39500\n4775500\n\n\n397162\n124500\n4687500\n\n\n434666\n41500\n4727500\n\n\n478383\n49500\n4789500\n\n\n488973\n329500\n4807500\n\n\n394153\n77500\n4684500\n\n\n426962\n36500\n4718500\n\n\n362216\n148500\n4651500\n\n\n\n\n\nThe first thing is to import the file into a table.\n\nfires &lt;- read.table(\"./data/Module_1/fires.csv\",header=TRUE,sep=',')\n\nOnce data is imported we can take a look at the structure to make sure that everything went well. We should have integer values for each region:\n\nstr(fires)\n\n'data.frame':   25 obs. of  7 variables:\n $ YEAR    : int  1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 ...\n $ PORTUGAL: int  8441 5036 7705 6131 21896 10745 14327 14954 16101 19983 ...\n $ SPAIN   : int  12238 7570 8679 9247 20811 12913 13531 15955 14254 19263 ...\n $ FRANCE  : int  6249 4353 3043 2837 6763 5881 3888 4002 4769 4618 ...\n $ ITALY   : int  18664 9398 11972 13588 9669 14477 11965 14641 14412 11588 ...\n $ GREECE  : int  1442 1082 1266 1898 1284 1322 858 2582 2406 1763 ...\n $ EUMED   : int  47034 27439 32665 33701 60423 45338 44569 52134 51942 57215 ...\n\n\nNow we will calculate some descriptive statistics for each column to have a first approximation to the distribution of our data. To do this we will use the function summary() that will return some basic statistical values such as:\n\nQuantile\nMean\nMedian\nMaximum\nMinimum\n\n\nsummary(fires)\n\n      YEAR         PORTUGAL         SPAIN           FRANCE         ITALY      \n Min.   :1985   Min.   : 5036   Min.   : 7570   Min.   :2781   Min.   : 4601  \n 1st Qu.:1991   1st Qu.:14327   1st Qu.:12913   1st Qu.:4002   1st Qu.: 7134  \n Median :1997   Median :21870   Median :16771   Median :4618   Median : 9540  \n Mean   :1997   Mean   :20848   Mean   :16937   Mean   :4907   Mean   : 9901  \n 3rd Qu.:2003   3rd Qu.:26488   3rd Qu.:20811   3rd Qu.:6249   3rd Qu.:11965  \n Max.   :2009   Max.   :35697   Max.   :25827   Max.   :8005   Max.   :18664  \n     GREECE         EUMED      \n Min.   : 858   Min.   :27439  \n 1st Qu.:1322   1st Qu.:45623  \n Median :1486   Median :55215  \n Mean   :1656   Mean   :54249  \n 3rd Qu.:1898   3rd Qu.:62399  \n Max.   :2582   Max.   :75382  \n\n\nThe summary() function is not only used to obtain summaries of data through descriptive statistics, but can also be used in model type objects to obtain a statistical summary of the results, coefficients, significance … Later we will see an example of this applied on a linear regression model.\nLet’s now see what happens if we apply some of the functions presented above. Try running the following instructions:\n\nsum(fires)\n\n[1] 2762377\n\nmax(fires)\n\n[1] 75382\n\nmin(fires)\n\n[1] 858\n\n\nAs can be seen these 3 instructions work with a tablebut mean(), median() and sd() will not. We have to apply them to a single column:\n\nmean(fires$SPAIN)\n\n[1] 16937.24\n\nmedian(fires$SPAIN)\n\n[1] 16771\n\nsd(fires$SPAIN)\n\n[1] 5260.519\n\n\n\n\n2.9.2 The apply() function\nSo far we have seen how to apply some of the basic statistical functions to our data, applying those functions to the data contained in the matrix or some of its columns. In the case of columns we have manually specified which one to apply a function. However, we can apply functions to all elements of an array (columns or rows) using iteration functions.\nThe apply() function allows you to apply a function to all elements of a table. We can apply some of the functions before the rows or columns of an array. There are different variants of this function. First, as always, invoke the help of the function to make sure what we are doing.\n\nhelp(apply)\n\nAccording to the specified in the function help we can see that the apply () function works as follows:\n\n💡apply(x, margin, fun, …) \n\nWhere:\n\nX: data matrix.\nMARGIN: argument to specify whether the function is applied to rows (1) or columns (2).\nFUN: function to be applied (mean,sum…)\n\nFor example, if we want to sum the values of each country/region we will do as follows:\n\napply(fires,2,mean)\n\n    YEAR PORTUGAL    SPAIN   FRANCE    ITALY   GREECE    EUMED \n 1997.00 20848.20 16937.24  4907.16  9900.64  1655.80 54249.04 \n\n\nWell, almost there. We have included the YEAR column which is the first one:\n\napply(fires[,-1],2,mean)\n\nPORTUGAL    SPAIN   FRANCE    ITALY   GREECE    EUMED \n20848.20 16937.24  4907.16  9900.64  1655.80 54249.04 \n\n\n\n📝EXERCISE 1: Calculate the total number of fires on a yearly basis.\nDeliverable: \n\nWrite a text file (.txt) with the result.\n\n\n\n📝EXERCISE 2:  Open the file “barea.csv” (file containing Burned Area by year and country) and save it in an object named “barea” - Select and store in a new matrix the data from the year 2000 to 2009. - Calculate descriptive statistics 2000-2009. - Calculate the mean, standard deviation, minimum and maximum of all columns and save it to a new object.\nDeliverable: \n\nWrite a text file (.txt) with the result.\n\n\n\n 🪄EXERCISE 2 HINT: \nUse the apply function to calculate each statistic, separately.\n\n\n\n2.9.3 Installing packages\nWe have already seen how some of the basic functions of R. work. However, we have the possibility of extending the functionalities of R by importing new packages into our environment. These packages are developed by different research groups and/or individuals.\nThere are currently over 20015 packages available in the R project repository (CRAN). Obviously we do not need to know how each one of them works, but only focus on those that fit our needs.\n\n\nWarning: package 'rvest' was built under R version 4.3.3\n\n\nWarning: package 'ggplot2' was built under R version 4.3.3\n\n\nWarning: package 'tidyr' was built under R version 4.3.3\n\n\nWarning: package 'dplyr' was built under R version 4.3.3\n\n\n\n\n\n\n\n\n\nThe import and installation of new packages is carried out in 2 stages:\n\nobtaining and installing and internal call to the package.\nLoading the package into our session.\n\n\n\n2.9.4 Installing an external package\nWe will install the “foreign” package. This package provides functions for reading and writing data stored in different statistical software formats such as Minitab, S, SAS, SPSS, Stata, Systat … and to read and write dBase files such as attribute tables of vector layers in format shapefile. The first thing we will do is get the package via download. This can be done from the menu of R:\n\nPackages / Install packages …\nSelect download directory (mirror)\nSearch for “foreing”\n\nIf you are using RStudio simply go to the Packages tab in the lower right box and select the Install option. In the popup window select the Repository (CRAN, CRANextra) option in the drop-down menu and type the name of the package.\n\n\n\n\n\nInstalling a package using RStudio\n\n\n\n\nAnother option is to obtain the package in .zip format directly from the webpage of project R and use the function Install package (s) from local zip files … (or Package archives in RStudio).\nIt is also possible to install packages through instructions in the R window, which is the most recommended method7:\n\ninstall.packages(\"foreign\")\n\nAt this point we would have installed the package in our personal library of R. However, in order to use the functions of the new package in our R environment it is necessary to make an internal call to the package. This is generally done using the library() function8:\n\nlibrary(foreign)\n\nWarning: package 'foreign' was built under R version 4.3.3\n\n\nOnce this is done we have all the functions of the package ready to be used. All that is left is to learn how to use the functions of the package… which is easy to say but maybe not to do.\n\n\n2.9.5 Create a function\nSo far we have mainly seen how to use pre-designed functions either in the default installation or from other packages. However, there is the possibility of creating our own functions.\nA function is a group of instructions that takes an input or input data, and uses them to calculate other values, returning a result or product. For example, the mean() function takes as input a vector and returns as a result a numeric value that corresponds to the arithmetic mean.\nTo create our own functions we will use the object called function that constitute new functions. The usual syntax is:\n\n💡FunName &lt;- function(args){comands} \n\nWhere:\n\narguments are the arguments we want to pass to our function.\ncommands are the instructions needed to do whatever the function does.\n\nLet’s look at a simple example. We will create a function to calculate the standard deviation of a vector with numerical data. The standard deviation formula looks like this:\n\\[\n\\text{SD} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} (x_i - \\bar{x})^2}\n\\]\nWhich is essentially the square root (sqrt()) of the variance (var()):\n\ndesv &lt;- function(x){sqrt(var(x))}\n\nThe function name is desv(). This function requires a single argument (x) to be executed. Once the function is defined, it can be called and used as any other predefined function in the system.\n\ndata &lt;- 1:10\ndesv(data)\n\n[1] 3.02765\n\n\nLet’s see an example with 2 arguments. We will create a function to calculate the NDVI. The function will take as arguments two objects of vector type corresponding to the sensor Landsat TM channels 3 and 4:\n\nThe normalized difference vegetation index (NDVI) is a simple graphical indicator that can be used to analyze remote sensing measurements, typically but not necessarily from a space platform, and assess whether the target being observed contains live green vegetation or not wikipedia.org.\n\n\\[\nNDVI=\\frac{NIR-Red}{NIR+Red}\n\\]\nWhere \\(NIR\\)(y) is the near-infrarred band and \\(Red\\)(x) is the red band.\n\nndvi &lt;- function(x,y){(y-x)/(y+x)}\n\nAs we have said, once created we can use our functions in the same way as the rest of functions. This includes using the apply() function and its derived versions to iterate over rows and columns of an array or data frame.\nLet’s see an example with the function desv(), previously created applied to the data of number of fires:\n\napply(fires,2,desv)\n\n        YEAR     PORTUGAL        SPAIN       FRANCE        ITALY       GREECE \n    7.359801  9187.114305  5260.519400  1393.670265  3467.510729   496.662025 \n       EUMED \n13547.393887"
  },
  {
    "objectID": "index.html#plotting-with-r",
    "href": "index.html#plotting-with-r",
    "title": "Introduction to spatial statistics: Spatial Analysis with R - 111019",
    "section": "2.10 Plotting with R",
    "text": "2.10 Plotting with R\n\n2.10.1 Basic plots\nR is not just an environment for the implementation and use of functions for statistical calculation but it is also a powerful environment for generating and displaying plots. Creating plots is besides an effective and quick way to visualize our data. By doing so we can verify whether data was correctly imported or not. However, creating graphics is also done by command-line instructions, which can sometimes be a bit tricky, especially at the beginning.\nIn R we can create many types of plots. With some packages it is also possible to generate maps similar to those created by GIS, although for the moment we will only see some basic types such as:\n\nDot charts\nLine charts\nBarplots\nHistograms\nScatterplots\n\nBefore going into detail with the specific types of graphics we will see some general concepts which apply to the majority of plots:\n\nAll graphics always require an object that contains the data to be drawn. This object is usually specified in the first argument of the function corresponding to each type of chart.\nThere are a number of arguments to manipulate axis labels or the chart title:\n\n\nmain: text with the title of our plot.\nxlab: text for x axis label.\nylab: text for y axis label.\nxlim: vector with upper and low range for the x-axis.\nylim: vector with upper and low range for the y-axis.\ncex: number indicating the aspect ratio between plot elements and text. 1 by default.\ncol: changes de color the plotted element. See http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf\nlegend(): adds a legend element describing symbology.\n\n\n\n2.10.2 Dot or point plots\nThis is one of the most basic types of graphics if not the most basic one we can create. To create such a graph we will use the plot() function. Let’s look at a simple example using data from fires.csv9:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN)\n\n\n\n\n\n\n\n\nAs you can see, we are plotting data from the SPAIN column, ie, yearly fire occurrence data in Spain.\nRemember RStudio displays plots in the right-bottom window. In addition, if you need to take closer look use the Zoom button to pop-up a new plot window.\nLe’s tune up and enhance our plot. We can change the symbol type using the pch argument. You’ll find a list of symbol types (not just dot charts) at http://www.statmethods.net/advgraphs/parameters.html.\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4)\n\n\n\n\n\n\n\n\nWe can change symbol size using cex:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,cex=2)\n\n\n\n\n\n\n\n\nAnd we can change the color of the symbol with col:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,cex=2,col='red')\n\n\n\n\n\n\n\n\nThe col argument can be specified either using the color name as in the example or using its code number, hexadecimal or RGB so that col = 1, col = \"white\", and col = \"#FFFFFF\" are equivalent. In some types of symbols we can also change the color of the symbol background in addition to the symbol itself using the argument bg:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=21,cex=1,col='black',bg='red')\n\n\n\n\n\n\n\n\nThe finish our plot we will modify axis labels, add a title and a legend:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=21,cex=1,col='black',bg='red',\n     main='Number of fires in Spain',ylab = 'Number of fires',xlab = '')\n\n\n\n\n\n\n\n\nNote that we have used the xlab argument to leave the x-axis label blank. Now we add the legend. It is important you bear in mind that the legend is added with an additional command right after the plot statement. Legends in basic plots are just an image we add to an existing plot by emulating the symbol used in that plot using the legend() function:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=21,cex=1,col='black',bg='red',\n     main='Number of fires in Spain',ylab = 'Number of fires',xlab = '')\nlegend( \"topleft\" , cex = 1.3, bty = \"n\", legend = c(\"Spain\"), , text.col = c(\"black\"), col = c(\"red\") , pt.bg = c(\"red\") , pch = c(21) )\n\n\n\n\n\n\n\n\nBut, what if we want to add a second series of data? Then we proceed in a way similar to the legend() statement, but using the function points() similar to what we have seen in the plot() example. In the following code we add a second point data series with portugal:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=21,cex=1,col='black',bg='red',\n     main='Number of fires in Spain',ylab = 'Number of fires',xlab = '')\npoints(fires$PORTUGAL,pch=21,cex=1,col=\"blue\",bg=\"blue\")\n\n\n\n\n\n\n\n\nFinally, we update the legend to fit the new plot with the second series of data. To do that we simply include a second value on each argument using a vector:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=21,cex=1,col='black',bg='red',\n     main='Number of fires in Spain',ylab = 'Number of fires',xlab = '')\npoints(fires$PORTUGAL,pch=21,cex=1,col=\"blue\",bg=\"blue\")\nlegend( \"topleft\" , cex = 1.3, bty = \"n\", legend = c(\"Spain\",\"Portugal\"), , text.col = c(\"black\"), col = c(\"red\",\"blue\") , pt.bg = c(\"red\",\"blue\") , pch = c(21) )\n\n\n\n\n\n\n\n\nThe problem we are now experiencing is that data for Portugal doesn’t fit in the extent of the plot as it is. We should modify this using the xlim and ylim arguments. At this point x-axis works fine, so we’ll leave it as it is. The problem comes from y-axis. We can solve it by passing the ylim argument passing the minimum and maximum values of the fires data. We bring here some functions from Descriptive statistics and summaries.\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=21,cex=1,col='black',bg='red',\n     main='Number of fires in Spain',ylab = 'Number of fires',xlab = '',\n     ylim = c(min(fires[,2:6]),max(fires[,2:6])))\n     \npoints(fires$PORTUGAL,pch=21,cex=1,col=\"blue\",bg=\"blue\")\nlegend( \"topleft\" , cex = 1.3, bty = \"n\", legend = c(\"Spain\",\"Portugal\"), , text.col = c(\"black\"), col = c(\"red\",\"blue\") , pt.bg = c(\"red\",\"blue\") , pch = c(21) )\n\n\n\n\n\n\n\n\n\n📝EXERCISE 3:  Explain in detail how the statement ylim = c(min(fires[,2:6]),max(fires[,2:6])) works in terms of the max() and min() functions and its interaction with the firesobject.\nDeliverable: \n\nWrite a brief report describing the working procedure of the aforementioned instruction.\n\n\n\n\n2.10.3 Line plots\nWell, this is quite easy. In line plots we use lines to represent our data series instead of points which are the default symbol. How do we do that? Just adding an additionla argument to specify we want to use lines with type = 'l':\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,type='l',col='red')\n\n\n\n\n\n\n\n\nOf course we can change the line style:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,type='l', lty=2, col='red')\n\n\n\n\n\n\n\n\nAdding a second (or third, fourth,…,$n$) series is done with lines():\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,type='l', col='red',\n     ylim = c(min(fires[,2:6]),max(fires[,2:6])))\nlines(fires$PORTUGAL,cex=1,col=\"blue\",lty=2)\n\n\n\n\n\n\n\n\nWe now adapt the legend and add some titles and we are good to go:\n\npar(mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,type='l', col='red',\n     main='Number of fires in Spain',ylab = 'Number of fires',xlab = '',\n     ylim = c(min(fires[,2:6]),max(fires[,2:6])))\nlines(fires$PORTUGAL,cex=1,col=\"blue\",lty=2)\n\nlegend( \"topleft\" , cex = 1.3, , lty = c(1,2), legend = c(\"Spain\",\"Portugal\"), text.col = c(\"black\"), col = c(\"red\",\"blue\"))\n\n\n\n\n\n\n\n\n\n\n2.10.4 Histograms\nThe next type of chart we will see is the frequency histogram. It is a bar chart that represents the number of elements of a sample (frequency) that we find within a certain range of values.\nTo draw this type of plot R uses the function hist(), which requires as a mandatory argument a vector (or column/row of an array) with the data to be represented. As with all other chart types we have seen, we can use main, xlab… Let’s see at an example using the example data from the regression.txt file10 (See Table 4.1):\n\n\n\n\n\n\n\nTavg_max: maximum average temperature in June.\nTavg: average temperature in June.\nlong: longitude in UTM values EPSG:23030.\nlot: latitude in UTM values EPSG:23030.\nd_atl: distance in meters to the Atlantic sea.\nd_medit: distance in meters to the Mediterranean sea.\nelevation: elevation above sea level in meters.\n\n\nhist(regression$elevation)\n\n\n\n\n\n\n\n\nThen we use the arguments we have seen to customize the plot:\n\nhist(regression$elevation,breaks=15,main=\"Elevation frecuency distribution\",xlab=\"Elevation\",ylab=\"Frecuency\",col=\"blue\",border=\"white\",ylim=c(0,40),xlim=c(0,2000))\n\n\n\n\n\n\n\n\nThe only new parameters are:\n\nbreaks, used to specify the number of bars in the histrogram.\nborder, used the change the color of bar’s borders.\n\n\n\n2.10.5 Scatterplots\nSo far we have seen how to construct univariate graphs, ie, represent a single variable or data series. Next we will see a type of bivariate graph, the scatterplot. This type of chart is interesting to visualize relations between two variables, almost mandatory to explore correlation or collinearity in regression analysis. Let’s look at an example with our fire data.\nIn this case we introduce in the function plot() a second data argument (\\(y\\)) with a second vector with the data right after the first data argument (\\(x\\)):\n\nplot(regression$Tavg,regression$elevation)\n\n\n\n\n\n\n\n\nNote that the first data series goes to \\(x-axis\\) and the second to the \\(y\\). Again, we can customize the appearnce and symbols similar to the regural do plot:\n\nplot(regression$elevation, regression$Tavg,\n     main='Average temperature vs elevation',ylab = 'Temperature (Celsius)', xlab = 'Elevation (m)',\n     pch=21, col='black', bg='steelblue')\n\n\n\n\n\n\n\n\nA particularly useful function in combination with scatterplots is abline() which allows to incorporate a trend line to the plot. We will further explore this later.\n\nplot(regression$elevation, regression$Tavg,\n     main='Average temperature vs elevation',ylab = 'Temperature (Celsius)', xlab = 'Elevation (m)',\n     pch=21, col='black', bg='steelblue')\nabline(lm(regression$Tavg~regression$elevation), lty=2, col='gray20',lwd=3)\n\n\n\n\n\n\n\n\nPay attention to the order in which we have introduced the \\(x\\) and \\(y\\) data in plot() and abline(). It is the opposite!!.\n\n\n2.10.6 Multiple plots\nTo finish with plot creation we will see two last possibilities. The first one is how to combine several charts in a single figure and the second how to export an image file from our graphics.\n\n2.10.6.1 Create a combined plot\nCombining several graphs in R is possible thanks to the function par(mfrow = c(rows, columns)). Using this function we prepare the display window to include several graphs simultaneously:\n\npar(mfrow = c(2, 1),mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,type='l', col='red',\n     ylim = c(min(fires[,2:6]),max(fires[,2:6])))\nplot(fires$PORTUGAL,type='l',col=\"blue\",lty=2,\n     ylim = c(min(fires[,2:6]),max(fires[,2:6])))\n\n\n\n\n\n\n\n\n\n\n\n2.10.7 Export an image file\nSince R runs on so many different operating systems, and supports so many different graphics formats, it’s not surprising that there are a variety of ways of saving your plots, depending on what operating system you are using, what you plan to do with the graph, and whether you’re connecting locally or remotely.\nThe first step in deciding how to save plots is to decide on the output format that you want to use. The following table lists some of the available formats, along with guidance as to when they may be useful.\nHere’s a general method11 that will work on any computer with R, regardless of operating system or the way that you are connecting.\n\nChoose the format that you want to use. In this example, I’ll save a plot as a JPG file, so I’ll use the jpeg driver.\nThe only argument that the device drivers need is the name of the file that you will use to save your graph. Remember that your plot will be stored relative to the current directory. You can find the current directory by typing getwd() at the R prompt. You may want to make adjustments to the size of the plot before saving it. Consult the help file for your selected driver to learn how.\nNow enter your plotting commands as you normally would. You will not actually see the plot - the commands are being saved to a file instead.\nWhen you’re done with your plotting commands, enter the dev.off() command. This is very important - without it you’ll get a partial plot or nothing at all. So if we wanted to save a jpg file called “rplot.jpg” containing a plot of x and y, we would type the following commands:\n\n\njpeg('rplot.jpg', width = 800, height = 600, res=100)\n\n# Here goes the plot\npar(mfrow = c(2,1),mar=c(3.5, 3.5, 2, 1), mgp=c(2.4, 0.8, 0))\nplot(fires$SPAIN,pch=4,type='l', col='red',\n     ylim = c(min(fires[,2:6]),max(fires[,2:6])))\nplot(fires$PORTUGAL,type='l',col=\"blue\",lty=2,\n     ylim = c(min(fires[,2:6]),max(fires[,2:6])))\n\ndev.off()\n\npng \n  2"
  },
  {
    "objectID": "index.html#working-with-files",
    "href": "index.html#working-with-files",
    "title": "Introduction to spatial statistics: Spatial Analysis with R - 111019",
    "section": "2.8 Working with files",
    "text": "2.8 Working with files\nSo far we have seen how to enter data and create objects manually, but it is also possible, and in fact is most common, to read data from files and store it in an object. If the target data file is properly structured, we will create a matrix or a ‘data.frame’ object which we can manipulated afterwards.\n\n2.8.1 The working directory\nUsing data files normally requires us to specify the location of that file using paths. To avoid this, R has a tool that allow us to specify a target folder -the so-called working directory or folder- to work with.\nThe working directory is the default path for reading and writing files of any kind. We can know the path to the current working directory using the getwd() command. To set a new working directory, we use the command setwd(\"path\"). Remember that setwd() requires a string argument (whereas getwd() does not) to specify the path to the working directory (“path”).\n\ngetwd()\nsetwd('C:/Users/Marcos/Desktop/')\ngetwd()\n\nBy default, in Windows the working directory is set to the Documents folder.\nOnce the working directory is specified, everything we do in R (read files, export tables and/or graphics …) will be done in that directory. However, it is possible to work with other file system locations, specifying a different path through the arguments of some functions.\n\n\n2.8.2 Reading data files\nR allows you to read any type of file in ASCII format (text files). The most frequently used functions are:\n\nread.table() and its different variations\nscan()\nread.fwf()\n\nFor the development of this course we will focus on using the read.table() function as it is quite versatile and easy to use. Before starting to use a new function we should always take a look at the available documentation. we will take this opportunity to show you how to do this in R so that you begin to become familiar R help.\nAny available function in R, regardless of being a standard one or belonging to an imported package has a documentation entry in the R help. R help describes us in detail the use of any function, providing information of the different arguments of the function, argument types, defaults, reference to the method (when applies) and even short code examples. To access the help we will use the help() function as follows:\n\nhelp(read.table)\n\nEntering the help() function we access the manual. In this case we can see a brief description of the function read.table() and its different variants (read.csv(), …). Below is the description of the arguments of the function, followed by some examples of application. This is the usual procedure for all functions available in R.\n\n\n\nHelp example\n\n\nIn case we use the regular R interface or the cmd terminal, the help entry will open in our default web browser.\nAt first glance the read.table() function seems to require many arguments, while its variations seem simpler. As already mentioned, arguments are just parameters that we can specify or change to execute a function, thus tunning the operation of the functions and the result to be obtained.\nArguments are specified within the function separated by commas (“,”). However, it is not necessary to assign a value to each one of them, since in the case of omitting an argument it is assigned a default value (always reported in the help entry). In the case of read.table() versus other functions like read.csv() the main advantage of using the first is that we can manipulate any argument, whereas most of them are fixed in the later. read.csv() is desigend to open comma separate files following the north-american standard (, as field delimiter and . as decimal separator). On the other hand, read.table() can potentially open any text file regardless of the separator, encoding, decimal format and so on so forth. Most of the executions of read.table() consist of:\n\n💡read.table(file,header=TRUE, sep=“,”,dec=“.”)\n\n\nfile: path and name of the file to open.\nheader: TRUE/FALSE argument to determine whether the first row of the data file contains column names.\nsep: field or column separator4.\ndec: decimal separator.\n\nLet’s see an example of reading file. We will read the file coordinates.txt, located in the Data directory. The file is structured in 3 columns with heading and separated by “;”. Al data are integer so no decimal separator is needed. See Table 2.2.\n\n\n\nStructure of the coordinates.txt file.\n\n\nFID_1\nX_INDEX\nY_INDEX\n\n\n\n\n364011\n82500\n4653500\n\n\n371655\n110500\n4661500\n\n\n487720\n55500\n4805500\n\n\n474504\n28500\n4783500\n\n\n436415\n85500\n4729500\n\n\n457549\n38500\n4757500\n\n\n469377\n39500\n4775500\n\n\n397162\n124500\n4687500\n\n\n434666\n41500\n4727500\n\n\n478383\n49500\n4789500\n\n\n488973\n329500\n4807500\n\n\n394153\n77500\n4684500\n\n\n426962\n36500\n4718500\n\n\n362216\n148500\n4651500\n\n\n\n\n\nThe process to follow is:\n\nSet working directory.\nUse the function to save the data in an object.\n\nIf we do…\n\nsetwd('.C/Users/Pere/INTRO_R/')\nread.table('./data/Module_1/coordinates.txt',header=TRUE,sep=';')\n\n…as we have not specified any object in which to store the result of the function, the contents of the file are simply printed on the terminal. This is a usual mistake, don’t worry. To store and later access the contents of the file we will do the following:\n\ntable&lt;-read.table('./data/Module_1/coordinates.txt',header=TRUE,sep=';')\ntable\n\n    FID_1 X_INDEX Y_INDEX\n1  364011   82500 4653500\n2  371655  110500 4661500\n3  487720   55500 4805500\n4  474504   28500 4783500\n5  436415   85500 4729500\n6  457549   38500 4757500\n7  469377   39500 4775500\n8  397162  124500 4687500\n9  434666   41500 4727500\n10 478383   49500 4789500\n11 488973  329500 4807500\n12 394153   77500 4684500\n13 426962   36500 4718500\n14 362216  148500 4651500\n\n\nPlease note that:\n\nYou have to specify your own working directory.\nThe path to the directory is specified in text format, so you type “in quotation marks”.\nThe name of the file to be read is also specified as text.\nThe header argument only accepts TRUE or FALSE values.\nThe sep argument also requires text values to enter the separator5.\nIt is advisable to save the data an object (table &lt;-).\n\nThe result of read.table() is an array stored in an object named table. Since read.table() returns an array we can manipulate our table using the same procedure described in the @ref(arrays) section.\n\ntable[,1]\n\n [1] 364011 371655 487720 474504 436415 457549 469377 397162 434666 478383\n[11] 488973 394153 426962 362216\n\ntable[1,1]\n\n[1] 364011\n\n\nBelow we found some interesting functions to preview and verify the information, and to know the structure of the data we have just imported. These functions are normally used to take a quick look into the first and last rows of an array or data.frame object and also to describe the structure of a given object.\n\nhead(): displays the first rows of the array.\ntail(): displays the last rows of the array.\nstr(): displays the structure and data type (factor or number).\n\n\nhead(table)\n\n   FID_1 X_INDEX Y_INDEX\n1 364011   82500 4653500\n2 371655  110500 4661500\n3 487720   55500 4805500\n4 474504   28500 4783500\n5 436415   85500 4729500\n6 457549   38500 4757500\n\ntail(table)\n\n    FID_1 X_INDEX Y_INDEX\n9  434666   41500 4727500\n10 478383   49500 4789500\n11 488973  329500 4807500\n12 394153   77500 4684500\n13 426962   36500 4718500\n14 362216  148500 4651500\n\nstr(table)\n\n'data.frame':   14 obs. of  3 variables:\n $ FID_1  : int  364011 371655 487720 474504 436415 457549 469377 397162 434666 478383 ...\n $ X_INDEX: int  82500 110500 55500 28500 85500 38500 39500 124500 41500 49500 ...\n $ Y_INDEX: int  4653500 4661500 4805500 4783500 4729500 4757500 4775500 4687500 4727500 4789500 ...\n\n\nAs already mentioned, read.table() is adequate to start reading of files to incorporate data into our working session in R. In any case we must be aware that there are other possibilities such as the read.csv() and read.csv2() that we have already seen when accessing the read.table() description. These functions are variations that defaults some arguments such as the field separator (columns) or the decimal character. In the help of the function you have information about it.\n\n\n2.8.3 Writing text files\nOf course, we can also write text files from our data. The procedure is quite similar to read data but using write.table() instead of read.table. Remember that the created files are saved into the working directory, unless you specify an alternative path in the function arguments. As always, before starting the first thing is to consult the help of the function.\n\nhelp(\"write.table\")\n\nThe arguments of the function are similar to those already seen in read.table ():\n\n💡write.table(object,file,names,sep)\n\n\nobject: object of type matrix (or dataframe) to write.\nfile: name and path to the created file (in text format).\nrow.names: add or not (TRUE or FALSE) queue names. FALSE is recommended.\nsep: column separator (in text format).\ndec: decimal separator (in text format).\n\nTry the following instructions6 and observe the different results:\n\nwrite.table(table,'table1.txt',row.names=TRUE,sep='\\t')\nwrite.table(table,'table2.txt',row.names=FALSE,sep='\\t')\nwrite.table(table,'table3.txt',row.names=FALSE,sep=';')\nwrite.table(table,'your path/table4.txt',sep=';')\nwrite.csv(table,'your path/table5.csv')\n\n\n\n2.8.4 Data manipulation\nLet’s see the most common instructions for manipulating and extracting information in R. Specifically we will see how to extract subsets of data from objects of type vector, array or dataframe. We will also see how to create new data sets from the aggregation of several objects. There are many commands that allow us to manipulate our data in R. Many things can be understood as manipulation but for the moment we will focus on:\n\nSelect or extract information\nSort tables\nAdd rows or columns to a table\n\nAs you might already guess, we will work with tabular data like arrays and data.frames which we further refer to as tables.\n\n2.8.4.1 Working with columns\nThe first thing we will do is access the information stored in the column(s) of a given table object. There are two basic ways to do this:\n\nUsing the position index of the column.\nUsing the name (header) of the column.\n\nThese two basic forms are not always interchangeable, so we will use one or the other depending on the case. It is recommended that you use the one that feels most comfortable for you. However, in most examples the column position index is used since it is a numerical value that is very easily integrated with loops and other iterative processes.\n\n2.8.4.1.1 Extracting columns\nTo extract columns using the position index we will use a series of instructions similar to those already seen in extracting information from Arrays, Vectors and Lists. The following statement returns the information of the second column of the array object table and stores it in a new object that we called col2:\n\ncol2 &lt;- table[,2]\ncol2\n\n [1]  82500 110500  55500  28500  85500  38500  39500 124500  41500  49500\n[11] 329500  77500  36500 148500\n\n\nIt is also possible to extract a range of columns, proceeding in a similar way to what has already been seen in the creation of vectors. The following statement extracts columns 2 and 3 from the table object and stores them in a new object called cols:\n\ncols &lt;- table[,2:3]\ncols\n\n   X_INDEX Y_INDEX\n1    82500 4653500\n2   110500 4661500\n3    55500 4805500\n4    28500 4783500\n5    85500 4729500\n6    38500 4757500\n7    39500 4775500\n8   124500 4687500\n9    41500 4727500\n10   49500 4789500\n11  329500 4807500\n12   77500 4684500\n13   36500 4718500\n14  148500 4651500\n\n\nNow let’s see how to select columns using their name. Name extraction is performed using a combination of object and column name object using $ to separte object from column name. The following statement selects the column named Y_INDEX from the array object table and stores it in col.Y_INDEX:\n\ncol.Y_INDEX &lt;- table$Y_INDEX\ncol.Y_INDEX\n\n [1] 4653500 4661500 4805500 4783500 4729500 4757500 4775500 4687500 4727500\n[10] 4789500 4807500 4684500 4718500 4651500\n\n\nA key piece of information here is the name of the column which we need to know in advance. Well, we can check the original text file or inspect the object table using str(). We can also take look to the top-right window activaing the Environment sub-window and unwrap table but be aware this can be only accessed using RStudio.\nThe main difference between these two methods is that index selection makes it possible to extract column ranges easily. To do this using the name of the columns you have to use functions like subset():\n\ncols2 &lt;- subset(table, select = c(X_INDEX,Y_INDEX))\n\nUsing the argument select we can point the columns that we want to extract using a vector with column names. Using subset() it is also possible to specify the columns that we do NOT want to extract. To do this proceed as follows:\n\ncols2 &lt;- subset(table, select = -c(X_INDEX,Y_INDEX))\n\nIn this way we would only extract the first column, excluding X_INDEX and Y_INDEX. Of cours, we can do this using the column index as well:\n\ncols2 &lt;- table[,-(2:3)]\n\n\n\n2.8.4.1.2 Merge columns and tables\nThe main reason why we are learning how to manipulate table columns is to be able to prepare our data for other purposes. It may be the case we need to join tables or columns that proceed from the same original table. The instruction cbind() allow us to merge together several tables and/or vectors provided they have the same number of rows. We can merge as many objects as we want to, by separating them using ,:\n\ncols3 &lt;- cbind(col2,cols2)\ncols3\n\n        col2  cols2\n [1,]  82500 364011\n [2,] 110500 371655\n [3,]  55500 487720\n [4,]  28500 474504\n [5,]  85500 436415\n [6,]  38500 457549\n [7,]  39500 469377\n [8,] 124500 397162\n [9,]  41500 434666\n[10,]  49500 478383\n[11,] 329500 488973\n[12,]  77500 394153\n[13,]  36500 426962\n[14,] 148500 362216\n\n\n\n\n2.8.4.1.3 Changing column names\nIt is often the case we need to alter or change the name of a table object. If we wanted to rename all the columns of an object we would to pass a vector with names to the function colnames() in case we are renaming an array or names() if we are dealing with a data.frame. Note that the vector should have the same length as the total number of columns. Lets rename our table cols3:\n\ncolnames(cols3)&lt;- c(\"COL1\",\"COL2\")\n\nWhat if we want to change only a given name. Then we just point to the column header using the position index like this:\n\ncolnames(cols3)[2]&lt;- \"RENAMED COLUMN\"\n\nYou may be wondering How can we know what kind of object is my table?. That is a very good question. Specially at the begining is quite difficult to be in control this stuff. If you use RStudio you already see a description of the objects in the top-right window. array or matrix objects show something like [1:14,1:2] indicating multiple dimensions, vectors are similar but with only 1 dimension [1:14] and data.frames show the word data.frame in their description. However, this is not the fancy way to deal with object types. Just for the record, when we mean type an actual code developer means class. Of course there is a function called class() that returns the class an object belongs to:\n\nclass(cols3)\n\n[1] \"matrix\" \"array\" \n\n\n\n\n2.8.4.1.4 Sorting our data\nFinally, let’s look at how to sort columns and arrays. To sort a column in R, the sort() function is used. The general function of the function is:\n\nsort(cols3[,1])\n\n [1]  28500  36500  38500  39500  41500  49500  55500  77500  82500  85500\n[11] 110500 124500 148500 329500\n\n\nIf we want to reorder an array based on the values of one of its columns, we will use the order () function. The general operation of the function is:\n\ntable[order(table$X_INDEX),]\n\n    FID_1 X_INDEX Y_INDEX\n4  474504   28500 4783500\n13 426962   36500 4718500\n6  457549   38500 4757500\n7  469377   39500 4775500\n9  434666   41500 4727500\n10 478383   49500 4789500\n3  487720   55500 4805500\n12 394153   77500 4684500\n1  364011   82500 4653500\n5  436415   85500 4729500\n2  371655  110500 4661500\n8  397162  124500 4687500\n14 362216  148500 4651500\n11 488973  329500 4807500\n\n\nTo be honest, in this last example we are actually working with rows. Take a look at the position of the ,. The brackets are also something that we will use later to extract data from a table. But it feels right to bring here the order() command right after sort().\n\n\n\n2.8.4.2 Working with rows\nLet us now turn to the manipulation of rows. The procedure is basically the same as in the case of columns, except for the fact that we normally do not work with names assigned to rows (although that’s a possibility), but we refer to a row using its position. To extract rows or combine several objects according to their rows we use the following expressions:\n\nrow1 &lt;- table[1:5,]\nrow2 &lt;- table[-(6:7),]\nrow3 &lt;- rbind(row1,row2)\n\nSame as with Arrays we point to rows instead of columns when we use the index value to the left of the [row,col]. So that’s the thing, we just change that and we are dealing with rows. We can join rows and tables using the rbind() function rather than cbind(). r stands for row and c for column.\nWe can extract a subsample of rows that meet a given criteria:\n\n💡table[criteria,]\n\n\ntable[table$X_INDEX==82500,]\n\n   FID_1 X_INDEX Y_INDEX\n1 364011   82500 4653500\n\ntable[table$X_INDEX&gt;82500,]\n\n    FID_1 X_INDEX Y_INDEX\n2  371655  110500 4661500\n5  436415   85500 4729500\n8  397162  124500 4687500\n11 488973  329500 4807500\n14 362216  148500 4651500\n\n\nOh, we expect you to have found out this by yourself but evidently we can combine row and column manipulation if that fits our purpose."
  }
]